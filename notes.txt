bobbyhack notes

https://www.bobbydurrettdba.com/nethackgame/

nethack@bobbydurrettdba.com

5/23/19

bobbyhack in its current state is some point in the 3.6.2 beta github stream of commits with four of my 
branches merged into it. They are:

tigerfix
silversword
crazyants
building

I have been doing some brainstorming and I want to move forward with bobbyhack as the base branch for 
my own version of nethack. 

At this point the four branches I created are not part of any cohesive plan or adventure but I hope over
time to mold bobbyhack into my own game with some interesting parts to it. Whether I have time to do so
does not matter. Here are some key ideas:

If I want to catch up with newer code from the Dev team create a new branch off of bobbyhack and work out
the merge issues with the new code. Then merge that branch back in.

If I want to work on some new idea make a branch off of bobbyhack and not the main devteam branch (3.6 at this time).
That way I will always be making changes that are compatible with my game. If I ever write something useful I can 
always go back and retrofit the change to be a patch on top of the latest version or the ongoing git stream.

Keep this file in the commits as my notes of what I am doing. If I merge a branch back into bobbyhack it will have 
an updated version of this file. I have taken a similar approach with the repositories that I used for my
Rosetta Code contributions and I like having a log of what I'm doing in a text file on GitHub.

I debated starting bobbyhack over from scratch from the recently released 3.6.2 release but decided to move forward
from bobbyhack as it is today and merge in devteam changes as desired. Also, I thought about not using the four
existing branches because they are not designed to fit into any story or adventure. But, I can always back them out 
later if I decide to not use them. I put time into testing them so I want to keep them in my code.

Last time I rebased bobbyhack and then added in the four branches. I don't really care about rebasing to clean
up the way the commits look. I want to keep my existing bobbyhack commits out there and move forward. I deleted
my rebase.sh script so I would not accidentally redo the rebasing of bobbyhack.

I thought about coming up with some new clever name like Terebynthia or something but I'm already attached to 
bobbyhack so that is another reason to move forward.

I can follow the devteam's latest code in nethack-git repo while keeping bobbyhack in a separate repo.

Probably my first task after creating this notes.txt file will be to try to merge in the 3.6.2 release changes.

5/24/19

Working on merging in the 3.6.2 release changes.

Merged in 3.6.2 updating monst.c to use 3.6.2 queen bee last line.

Deleted Makefiles. Need to redeploy and manually edit for GAME=bobbyhack
and flex and bison.

Looks like 3.6.2 added another field in the MON macro in monst.c.

Picked a number for crazy ants like a giant ant.

Seems to work.

4/28/2020

Working on adding in the 3.6.6 changes.

[bobby@localhost bobbyhack]$ git checkout bobbyhack
Switched to branch 'bobbyhack'
[bobby@localhost bobbyhack]$ view notes.txt
[bobby@localhost bobbyhack]$ pwd
/home/bobby/nethack/bobbyhack
[bobby@localhost bobbyhack]$ git branch add366
[bobby@localhost bobbyhack]$ git checkout add366
Switched to branch 'add366'

bunch of stuff to get this working

cd /home/bobby/nethack/nethack-git
git fetch upstream
git checkout NetHack-3.6
git merge --ff-only upstream/NetHack-3.6
git push

git push --set-upstream origin NetHack-3.6

git branch --set-upstream-to=remotes/upstream/NetHack-3.6

did not seem to be any conflicts. Good be pretty easy.

[bobby@localhost nethack]$ bhbuild.sh

does tags and all

current branch

everything looks good. Not so bad.

5/2/2020

created autoletter branch

5/3/2020

Created a simple function to write a string to a debugging file.

File is /home/bobby/nethack/debugfile.log

Function is write_debug_file(char *string) in files.c.

Can use it anywhere.

Could create formatted front ends to write_debug_file like

write_debug_file_int(char *format,int data)

int snprintf(formatted_string, 80, format, data);

If formats to more than 80 characters abort.

Could do one for each type we might need. Not sure yet what those would be.

debug functions are up to these now: (in extern.h)

/* Bobby Durrett debug file functions */

E void write_debug_file(char *string);
E void write_debug_file_datetime();
E void write_debug_file_str(char *format,char *data);
E void write_debug_file_int(char *format,int data);

could clone write_debug_file_str or write_debug_file_int for other types
just passes one parameter into format string. should be ok for debugging.

possible other types for debug:

    unsigned oeaten;        /* nutrition left in food, if partly eaten */
    long age;               /* creation date */
    short otyp; /* object class number */
    schar spe; /* quality of weapon, weptool, armor or ring (+ or -);
    xchar ox, oy;
    Bitfield(cursed, 1);


typedef signed char schar;

https://vim.fandom.com/wiki/Browsing_programs_with_tags

typedef schar xchar;

looks like we need short, long, char.

unsigned can work with int

https://en.wikipedia.org/wiki/C_data_types

Looks like long would be helpful. Others can adjust.

added

E void write_debug_file_long(char *format,long data);

5/4/2020

Cleaned up the debug file stuff a little bit.

Put test code in /home/bobby/debugfile

5/9/2020

Poking around.

boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;

in options.c

I think it is called for each option in .nethackrc

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none


boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;
{
    write_debug_file_str("In parseoptions opts = %s\n",opts);


[bobby@localhost debugfile]$ cat /dev/null > debugfile.log;tail -f debugfile.log
In parseoptions opts = noshowexp,showscore,time,color,!autopickup
In parseoptions opts = showscore,time,color,!autopickup
In parseoptions opts = time,color,!autopickup
In parseoptions opts = color,!autopickup
In parseoptions opts = !autopickup
In parseoptions opts = autodig,ibmgraphics,autoquiver,noautoopen
In parseoptions opts = ibmgraphics,autoquiver,noautoopen
In parseoptions opts = autoquiver,noautoopen
In parseoptions opts = noautoopen
In parseoptions opts = number_pad:0,msg_window:reversed
In parseoptions opts = msg_window:reversed
In parseoptions opts = hilite_pet,hilite_pile,pickup_burden:unencumbered
In parseoptions opts = hilite_pile,pickup_burden:unencumbered
In parseoptions opts = pickup_burden:unencumbered
In parseoptions opts = disclose:yi ya yv yg yc yo
In parseoptions opts = boulder:`
In parseoptions opts = sortloot:none

Looks like it just processes the first option passed to it.

    if ((op = index(opts, ',')) != 0) {
        *op++ = 0;
        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

I guess this sticks a 0 where the first comma is so the rest of the function
can use opts as if it didn't have a comma.

Then it calls itself with op pointing to the string after the comma.

[bobby@localhost src]$ grep parseoptions *.c
files.c:        ++bufp; /* skip '='; parseoptions() handles spaces */
files.c:        if (!parseoptions(bufp, TRUE, TRUE))
options.c:             * parseoptions() will check each individually
options.c:            (void) parseoptions(opts, TRUE, FALSE);
options.c:/* paranoia[] - used by parseoptions() and special_handling() */
options.c:parseoptions(opts, tinitial, tfrom_file)
options.c:        if (!parseoptions(op, initial, from_file))
options.c:         * or prompt for new values. In most cases, call parseoptions()
options.c:                (void) parseoptions(buf, setinitial, fromfile);
options.c:                    (void) parseoptions(buf, setinitial, fromfile);
options.c:        /* parseoptions will prompt for the list of types */
options.c:        (void) parseoptions(strcpy(buf, "pickup_types"),
vision.c: *      + After an option has changed that affects vision [parseoptions()]

Mostly return value is ignored except in files.c.

        if (!parseoptions(bufp, TRUE, TRUE))
            retval = FALSE;

this uses returned value in files.c
in function 

boolean
parse_config_line(origbuf)
char *origbuf;

But what the heck is parse_config_line doing?

boolean
parse_config_line(origbuf)
char *origbuf;
{
    write_debug_file_str("In parse_config_line origbuf = %s\n",origbuf);


clear; cat /dev/null > debugfile.log;tail -f debugfile.log

In parse_config_line origbuf = WIZARDS=bobby
In parse_config_line origbuf = EXPLORERS=*
In parse_config_line origbuf = MAXPLAYERS=10
In parse_config_line origbuf = GDBPATH=/usr/bin/gdb
In parse_config_line origbuf = GREPPATH=/bin/grep
In parse_config_line origbuf = PANICTRACE_GDB=1
In parse_config_line origbuf = PANICTRACE_LIBC=2
More than MAX_LINE_SIZE character string in write_debug_file_str
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=number_pad:0,msg_window:reversed
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=disclose:yi ya yv yg yc yo
In parse_config_line origbuf = OPTIONS=boulder:`
In parse_config_line origbuf = OPTIONS=sortloot:none

I guess these are the uncommented lines in sysconf as well as the .nethackrc

[bobby@localhost nethack]$ grep = /home/bobby/nethack/games/lib/bobbyhackdir/sysconf | grep -v \#
WIZARDS=bobby
EXPLORERS=*
MAXPLAYERS=10
GDBPATH=/usr/bin/gdb
GREPPATH=/bin/grep
PANICTRACE_GDB=1
PANICTRACE_LIBC=2

I'm thinking autoletter should be an option since it is related to game
play and not configuration of the system relative to Linux.

5/10/2020

[bobby@localhost ~]$ diff .nethackrc .nethackrc.workingsave

.nethackrc.workingsave is my normal options for nethack 3.6.x

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=autoletter:blindfold:1

simple test of one autoletter option.

[bobby@localhost ~]$ bobbyhack -D

OPTIONS=autoletter:blindfold:1
 * Line 1: Unknown option 'autoletter:blindfold:1'.

1 error in /home/bobby/.nethackrc.


Hit return to continue:

probably here

[bobby@localhost src]$ grep "Unknown option" *.c
options.c:    config_error_add("Unknown option '%s'", opts);

    /* out of valid options */
    config_error_add("Unknown option '%s'", opts);
    return FALSE;
}

this is called if you fall through to this point.

This is the end of parseoptions in options.c

Maybe add the autoletter support here.

/* compound options, for option_help() and external programs like Amiga
 * frontend */
static struct Comp_Opt {
    const char *name, *descr;
    int size; /* for frontends and such allocating space --
               * usually allowed size of data in game, but
               * occasionally maximum reasonable size for
               * typing when game maintains information in
               * a different format */
    int optflags;
} compopt[] = {
    { "align", "your starting alignment (lawful, neutral, or chaotic)", 8,
      DISP_IN_GAME },
    { "align_message", "message window alignment", 20, DISP_IN_GAME }, /*WC*/
    { "align_status", "status window alignment", 20, DISP_IN_GAME },   /*WC*/

Seems like we may not need to add autoletter to compopt[] in options.c at first just to get it working
but later to add it to the help for options.

Probably just need to handle autoletter at the end of parseoptions for now.

    /* control over whether highlights should be displayed, and for how long */
    fullname = "statushilites";
    if (match_optname(opts, fullname, 9, TRUE)) {
#ifdef STATUS_HILITES
        if (negated) {
            iflags.hilite_delta = 0L;
        } else {
            op = string_for_opt(opts, TRUE);
            iflags.hilite_delta = (op == empty_optstr || !*op) ? 3L : atol(op);
            if (iflags.hilite_delta < 0L)
                iflags.hilite_delta = 1L;
        }
        if (!tfrom_file)
            reset_status_hilites();
        return retval;
#else
        config_error_add("'%s' is not supported", fullname);
        return FALSE;
#endif
    }

possible example. could use fullname = "autoletter";

Not sure if I should use something like

#ifdef AUTOLETTER to bracket the code? Kind of gross.

If I am going to do it I should do something like

#ifdef DEBUG_FILE for the debugging code.

I think retval is set by the earlier recursive call

        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

So if current option is good return retval otherwise
return FALSE.

5/19/2020

in options.c

/* check whether a user-supplied option string is a proper leading
   substring of a particular option name; option string might have
   a colon or equals sign and arbitrary value appended to it */
boolean
match_optname(user_string, opt_name, min_length, val_allowed)
const char *user_string, *opt_name;
int min_length;
boolean val_allowed;

I guess use this:

    /* automatically set objects to a specific letter */
    fullname = "autoletter";
    if (match_optname(opts, fullname, 10, TRUE)) {
        write_debug_file_str("autoletter opts = %s\n",opts);
        return retval;
    }
    
[bobby@localhost ~]$ cat .nethackrc
OPTIONS=autoletter:blindfold:1

debug output:

autoletter opts = autoletter:blindfold:1

switched to 7 letters so autolet works.

autoletter opts = autoletter:blindfold:1
autoletter opts = autolet:blindfold:1
autoletter opts = autoletter:blindfold:1

Duh.

should be like this

autoletter opts = autoletter:b:blindfold:1

letter:object type or name:integer priority


void
add_autoletter(char *opts)
{
    write_debug_file_str("In add_autoletter opts = %s\n",opts);
}

shell of where to do actual insert into data structure

strchr to find a string

need to add validation code in add_autoletter
to make sure isn't a huge string et. al. and that
it has the proper number of :'s and all.
Also having it default to priority 1 without the last
: and having a prefix for autoletter.

might need config_error_add and similar routines
to report an error

/* varargs 'config_error_add()' moved to pline.c */

config_error_add("Unknown %s '%s'", fullname, op);

5/20/2020

add_autoletter is parsing out the autoletter option
pretty well with error checking.

getting super annoying clock skew message need to figure
out how to sync Linux VM clock with my Windows laptop host.
Maybe part of tools for virtualbox?

should I put this code in its own function and call
it from add_autoletter?

maybe parse_autoletter?

5/23/2020

was getting weird time skew errors until I realized that my
Windows 10 laptop was the one that was out of sync somehow.

Had to go to Date and time settings and click on
Sync now button to resolve.

Moved autoletter option parsing code into
parse_autoletter to keep add_autoletter
cleaner.

5/25/2020

Need to save in an array now.

boolean
insert_autoletter(char letter,char *object_type_or_name, int priority)

I guess since the array is static and the debug file commands are in files.c
I cannot write a debug print command to directly access the array.

I could write interface functions to get num_autoletter and
a specific element of the array.

int num_autoletter()

boolean get_autoletter(int index,char *letter,char *object_type_or_name, int *priority)

then I could write 

void
write_debug_file_autoletter()

to dump the entire array in a nicely formatted output.

Could test with my entire option list as I want to use it

(blindfold, lamp, etc.)

Need to test all the bad cases such as

not a alpha letter

priority < 1

also need to add a check for duplicate object type or name.
and make sure there is a meaningful error message.

should I add config error messages to insert_autoletter
itself.

maybe create

int lookup_autoletter(char *object_type_or_name)

returns index into array >= 0 < MAX_AUTO_OPTIONS

then combine with get_autoletter to return actual values.

that way get_autoletter can be used to interate through
entire array and to pull data back for a looked up
index

not sure it makes sense to call config_error_add
in insert_autoletter. may have to move out if I end up
calling insert_autoletter from somewhere else
such as users changing options on the fly.

I wonder if here:

    if (!parse_autoletter(opts,&letter,object_type_or_name,&priority))
        return FALSE;

    return insert_autoletter(letter, object_type_or_name, priority);

I should make both calls - parse_autoletter and insert_autoletter
return an error string and call config_error_add within add_autoletter.

top level add_autoletter could be like

add_autoletter_config

to indicate it is from config file.

That would keep parse_autoletter and insert_autoletter available for
non-config-file uses.

But then again if users adjusted the config in the program would probably 
not use parse_autoletter.

could have a wrapper to insert_autoletter called 
insert_autoletter_config that did the error writing.

Not sure.

or just stick with this as only from the config file for now.
It really does not need to change in the middle of the game.

write these next:

int num_autoletter()

boolean get_autoletter(int index,char *letter,char *object_type_or_name, int *priority)

void write_debug_file_autoletter()

stick in extern.h

add debug to write out opts in add_autoletter and the call
write_debug_file_autoletter at the end.

maybe

    return insert_autoletter(letter, object_type_or_name, priority);

change to

    if (!insert_autoletter(letter, object_type_or_name, priority))
        return FALSE;
        
    write_debug_file_autoletter()
    
    return TRUE;

Then I could really see the options loading into the array.

boolean
add_autoletter(char *opts)
{
    /* parsed option details */
    char letter;
    char object_type_or_name[MAX_OBJ_TYPE_NAME_LEN];
    int priority;

    write_debug_file_str("In add_autoletter opts = %s" ,opts);

    if (!parse_autoletter(opts,&letter,object_type_or_name,&priority))
        return FALSE;

    if (!insert_autoletter(letter, object_type_or_name, priority))
        return FALSE;

    write_debug_file_autoletter();

    return TRUE;
}

Now that this is there.

Maybe do more testing to make sure array is updated correctly.

Try my really intended options for one thing.

OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn


It looks like in the code they call oil lamp the name
and lamp the description.

I have been thinking of these as "object types"

names are in objects.c

In add_autoletter opts = autoletter:u:unicorn horn

Autoletter array length = 13

Inventory Letter     Object Type or Name                     Priority
---------------------------------------------------------------------
b                    blindfold                                      1
l                    magic lamp                                     1
l                    lamp                                           2
l                    oil lamp                                       2
l                    brass lantern                                  2
k                    key                                            1
k                    skeleton key                                   1
m                    mirror                                         1
m                    looking glass                                  1
w                    magic whistle                                  1
w                    whistle                                        2
p                    pick-axe                                       1
u                    unicorn horn                                   1

My full options:

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none
OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn

[bobby@localhost ~]$

8:52 PM

Next steps.

1 - need to go over my handwritten notes to see what I was thinking.

2 - I think I need to identify where objects are brought into the 
main inventory. My notebook had a list of ideas for this.
- game startup
- picking up object
- wishing for object
- taking out of a container
need to check my list.

3 - at those points call an autoletter routine for each object that
enters my inventory. That routine will look up the name or type of the
object in the array and return the letter it should switch to if any.

4 - once I identify which objects need to switch do the switch.
Maybe look at the preadjust and sticky code for ideas?
Maybe the #adjust code has the switch in it?

Could start with a stub that just writes to the debug file that 
we got there. Put it in the places identified by 2?

maybe call the stub autoletter_adjust and pass a pointer to the
object itself.

Ultimately all the code for 3 and 4 would be in autoletter_adjust.

Could start with a stub that prints the object information
such as its type, description, name, etc.

Put it in the locations from 2.

Then add the code to see if the object needs its inventory letter adjusted
which is 3.

The add the code to actually do the switch. (4.)

***********************************************************************************

NEXT STEP:

Write the autoletter_adjust([object type] *) stub with debug file outputs
for the object passed to it and
put it in places where objects come into the main inventory. Test. 

***********************************************************************************

5/27/2020

Need to put autoletter_adjust somewhere where I have an object pointer.

Look at preadjust

[bobby@localhost src]$ grep PREADJUST *.c
allmain.c:#ifdef PREADJUST
allmain.c:#endif /* PREADJUST */
files.c:#ifdef PREADJUST
files.c:        } else if (match_varname(buf, "PREADJUST", 6)) {
files.c:#endif /* PREADJUST */
invent.c:#ifndef PREADJUST
invent.c:#endif /* PREADJUST */
invent.c:#ifndef PREADJUST
invent.c:#endif /* PREADJUST */
invent.c:#ifdef PREADJUST
invent.c:#endif /* PREADJUST */
invent.c:#ifndef PREADJUST
invent.c:#endif /* PREADJUST */
options.c:#ifdef PREADJUST
options.c:#endif /* PREADJUST */
options.c:#ifdef PREADJUST
options.c:#endif /* PREADJUST */
restore.c:#ifdef PREADJUST
restore.c:#endif /* PREADJUST */


allmain.c

void
newgame()
{

#ifdef PREADJUST
	apply_preadjust();
	cleanup_preadjust();
#endif /* PREADJUST */

invent.c

int
doorganize()

options.c 

code here like in mine

void
apply_preadjust()
{
    int i;
    struct obj *obj;

    if (n_preadjust == 0)
	return;
    /* this is kind of expensive, I suppose, but it only happens once */
    for (i = 0; i < n_preadjust; i++) {
	for (obj = invent; obj; obj = obj->nobj) {
	    if (strstri(OBJ_NAME(objects[obj->otyp]), preadj_list[i].descr)) {
# ifdef STICKY_OBJECTS
		obj->sticky = preadj_list[i].sticky;
# endif /* STICKY_OBJECTS */
		doorganize_guts(obj, preadj_list[i].invlet, TRUE);
		break;
	    }
	}
    }
}

seems like this goes through the initial inventory
and readjusts it.

called from newgame()

could loop through the inventory in the same way
and call autoletter_adjust for each object.

would mean that autoletter_adjust operates on objects
after they are already put in the inventory.

obj.h

struct obj {

    char invlet;    /* designation in inventory */

    xchar where;        /* where the object thinks it is */

#define OBJ_INVENT 3    /* object in the hero's inventory */

should be where == OBJ_INVENT

struct oextra {
    char *oname;          /* ptr to name of object */

    struct oextra *oextra; /* pointer to oextra struct */

    Bitfield(known, 1);     /* exact nature known */
    Bitfield(dknown, 1);    /* color or text known */
    Bitfield(bknown, 1);    /* blessing or curse known */
    Bitfield(rknown, 1);    /* rustproof or not known */
    
might be relevant

need object description or name

onames.h has the otyp numbers

#define	DWARVISH_IRON_HELM	74

where are the names stored?

[bobby@localhost src]$ grep "small shield" *.c
objects.c:SHIELD("small shield", None,

 * The data in this file is processed twice, to construct two arrays.

and the array names are...?

NEARDATA struct objdescr obj_descr[] =

NEARDATA struct objclass objects[] =

maybe these two?

[bobby@localhost src]$ grep "obj_descr\[" *.c
do_name.c:                 : obj_descr[STRANGE_OBJECT].oc_name);
objects.c: * struct objdescr obj_descr[] =
objects.c:NEARDATA struct objdescr obj_descr[] =
options.c:    obj_descr[SLIME_MOLD].oc_name = "fruit";
pager.c:                              : an(obj_descr[STRANGE_OBJECT].oc_name));
pager.c:                     : obj_descr[STRANGE_OBJECT].oc_name);

in objclass.h

struct objdescr {
    const char *oc_name;  /* actual name */
    const char *oc_descr; /* description when name unknown */
};


void
autoletter_adjust(struct obj *obj)
{
    if (obj != NULL)
        write_debug_file_char("Inventory letter = %c\n",obj->invlet);
    else
        return;

    if (has_oname(obj))
        write_debug_file_str("Object name = %s\n",obj->oextra->oname);
    else
        write_debug_file("No object name\n");

    if (obj->where == OBJ_INVENT)
        write_debug_file("In inventory\n");
    else
        write_debug_file("Not in inventory\n");

    write_debug_file_int("object type number = %d\n",obj->otyp);

    write_debug_file_str("Object class name = %s\n",(char *)obj_descr[obj->otyp].oc_name);

    write_debug_file_str("Object class description = %s\n",(char *)obj_descr[obj->otyp].oc_descr);
}

shows the different types

probably could use these different fields and maybe some of the bitfields to figure out if the
object has a user given name and if the user knows the official name.

Some of this is stiff fuzzy like this one for potion of sickness:

Inventory letter = d
No object name
In inventory
object type number = 294
Object class name = sickness
Object class description = fizzy

Need to find the code that builds the full name potion of sickness, fizzy potion, etc.

5/29/2020

started putting object debugging code in
write_debug_file_obj(obj);

Need to get the full object name like

spellbook of remove curse

instead of

remove curse

sidetracked

in zap.c

        /* if type already discovered, treat this item has having been seen
           even if hero is currently blinded (skips redundant makeknown) */
        if (objects[obj->otyp].oc_name_known) {

Looks like if objects[obj->otyp].oc_name_known is true then you know the 
true name.

this whole routine in zap.c looks interesting

/* wand discovery gets special handling when hero is blinded */
void
learnwand(obj)
struct obj *obj;
{
    /* For a wand (or wand-like tool) zapped by the player, if the
       effect was observable (determined by caller; usually seen, but
       possibly heard or felt if the hero is blinded) then discover the
       object type provided that the object itself is known (as more
       than just "a wand").  If object type is already discovered and
       we observed the effect, mark the individual wand as having been
       seen.  Suppress spells (which use fake spellbook object for `obj')
       so that casting a spell won't re-discover its forgotten book. */
    if (obj->oclass != SPBOOK_CLASS) {
        /* if type already discovered, treat this item has having been seen
           even if hero is currently blinded (skips redundant makeknown) */
        if (objects[obj->otyp].oc_name_known) {
            obj->dknown = 1; /* will usually be set already */

        /* otherwise discover it if item itself has been or can be seen */
        } else {
            /* in case it was picked up while blind and then zapped without
               examining inventory after regaining sight (bypassing xname) */
            if (!Blind)
                obj->dknown = 1;
            /* make the discovery iff we know what we're manipulating */
            if (obj->dknown)
                makeknown(obj->otyp);
        }
        update_inventory();
    }
}

I guess obj->dknown is true if a specific object is know and
objects[obj->otyp].oc_name_known is true if the class of object
is known.

invent.c

void
update_inventory()
{
    if (restoring)
        return;

    /*
     * Ought to check (windowprocs.wincap2 & WC2_PERM_INVENT) here....
     *
     * We currently don't skip this call when iflags.perm_invent is False
     * because curses uses that to disable a previous perm_invent window
     * (after toggle via 'O'; perhaps the options code should handle that).
     */
    (*windowprocs.win_update_inventory)();
}

so need to find the win_update_inventory for tty I guess.
can't find it.

int
doorganize() /* inventory organizer by Del Lamb */

I think was modified in sticky

invent.c

objname.c

xname?

char *
xname(obj)
struct obj *obj;
{
    return xname_flags(obj, CXN_NORMAL);
}

maybe this

STATIC_OVL char *
xname_flags(obj, cxn_flags)
register struct obj *obj;
unsigned cxn_flags; /* bitmask of CXN_xxx values */
{
    register char *buf;
    register int typ = obj->otyp;
    register struct objclass *ocl = &objects[typ];
    int nn = ocl->oc_name_known, omndx = obj->corpsenm;
    const char *actualn = OBJ_NAME(*ocl);
    const char *dn = OBJ_DESCR(*ocl);
    const char *un = ocl->oc_uname;
    boolean pluralize = (obj->quan != 1L) && !(cxn_flags & CXN_SINGULAR);
    
maybe if I find the right cxn_flags values
I can get what I want.

files.c: In function ‘write_debug_file_obj’:
files.c:4850:64: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
     write_debug_file_str("xname_flags(obj, CXN_NORMAL) = %s\n",(char *)xname_flags(obj, CXN_NORMAL));

I guess the STATIC_OVL keeps you from using it.

/* like cxname, but ignores quantity */
char *
cxname_singular(obj)
struct obj *obj;

Inventory letter = h
No object name
In inventory
object type number = 281
Object class name = invisibility
Object class description = brilliant blue
cxname_singular(obj) = potion of invisibility

converts the full potion name.

I need to find a different place to put the call to 
write_debug_file_obj so I can try one object at a time
of my choosing. right now now I have it in newgame where
I am calling autoletter_adjust a bunch of times.

Looking at other code it seems to be more compact.
Probably trying to fit a lot of code in a more compact file
without commenting every line. :)

I can't really work on the object name stuff
until I can work on an object of my choosing.

5/30/2020

Think about what to do with objects that stack.

10 potions of holy water

10 +2 daggers

I am really thinking more about tools but need to handle other cases
or maybe not at first.

Maybe only accept tools at first.

Taking this out of allmain.c

    u_init();

    /* Bobby Durrett - added to apply autoletter options after
       initial setup. Pieces of code taken from Preadjust patch */

    struct obj *obj;

    /* loop through the objects in the newly created inventory */

    for (obj = invent; obj; obj = obj->nobj)
        autoletter_adjust(obj);

#ifndef NO_SIGNAL
    (void) signal(SIGINT, (SIG_RET_TYPE) done1);
#endif

Can always put back.

Need somewhere else to put write_debug_file_obj(obj)

invent.c

    /* Bobby Durrett - this might print from object in #adjust command */
        
    write_debug_file_obj(obj);

Inventory letter = e
No object name
In inventory
object type number = 198
Object class name = lock pick
Object class description = (null)
cxname_singular(obj) = lock pick

Worked.

So from letter will cause the object to go
to write_debug_file_obj and we can use that to experiment with
object names and what is known and unknown.

So if you look at a typical inventory

                        $ - 1695 gold pieces
                        Weapons
                        a - a +0 scalpel (weapon in hand)
                        Armor
                        b - an uncursed +1 pair of leather gloves (being worn)
                        Comestibles
                        k - 7 uncursed apples
                        Spellbooks
                        h - a blessed spellbook of healing
                        i - a blessed spellbook of extra healing
                        j - a blessed spellbook of stone to flesh
                        Potions
                        d - 3 uncursed potions of healing
                        e - a blessed potion of healing
                        f - 4 uncursed potions of extra healing
                        Wands
                        g - a wand of sleep (0:7)
                        Tools
                        c - an uncursed stethoscope


what I want in the autoletter array is the name without all the extra stuff

Singular without "a" or the number of items.

No b/u/c status.

No +1.

No rustproof etc.

Also for unknown items the unknown name

i.e. 

a fizzy potion 

would be 

fizzy potion

a scroll labeled PHOL ENDE WODAN.

would be

scroll labeled PHOL ENDE WODAN

n - a crystal wand.

wb

crystal wand

Artifacts and named objects:

p - the blessed +3 Frost Brand

wb

Frost Brand

a - a +0 scalpel named My Favorite Weapon (weapon in hand)

wb

My Favorite Weapon

the idea is that when an item enters my inventory it would look up this stripped down name in the 
autoletter array based on this order of priority (autoletter name)

1. Name of object - a name I gave it or an artifact name.

2. Unknown type - generic type like key or fizzy potion

3. Fully known type spellbook of healing

The rest of the object characteristics such as b/u/c, enchantment level, number of items, rustproof
would give it priority over an existing object of the same type. The priority number would help 
distinguish between multiple object_name_or_type values for the same letter,
but these characteristics would break the tie if there were multiple objects in the inventory with the 
same "autoletter name"

But first I need to figure out how to get the base name to poll the array with so I can use
write_debug_file_obj to figure that out and then make a function in objects.c that returns
the name for autoletter use.

a - a +0 battle-axe named My Axe (weapon in hands)

Inventory letter = a
Object name = My Axe
In inventory
object type number = 28
Object class name = battle-axe
Object class description = double-headed axe
cxname_singular(obj) = battle-axe named My Axe

cxname_singular is not it.

c - 56 +2 arrows (in quiver)

Inventory letter = c
No object name
In inventory
object type number = 1
Object class name = arrow
Object class description = (null)

Object class name works.

try a potion

g - an uncursed potion of enlightenment named My Potion

Inventory letter = g
Object name = My Potion
In inventory
object type number = 286
Object class name = enlightenment
Object class description = swirly

how do I get

swirly potion

potion of enlightenment

Cannot use xname_flags because it sticks in
the user supplied name.

hack.h

/* bitmask flags for corpse_xname();
   PFX_THE takes precedence over ARTICLE, NO_PFX takes precedence over both */
#define CXN_NORMAL 0    /* no special handling */
#define CXN_SINGULAR 1  /* override quantity if greather than 1 */
#define CXN_NO_PFX 2    /* suppress "the" from "the Unique Monst */
#define CXN_PFX_THE 4   /* prefix with "the " (unless pname) */
#define CXN_ARTICLE 8   /* include a/an/the prefix */
#define CXN_NOCORPSE 16 /* suppress " corpse" suffix */

Does not seem to be a way to get rid of it.

Of course we could just not use it if we have the name.

try

char *
simple_typename(otyp)

f - a cursed potion of levitation named Bobby's Potion

Inventory letter = f
Object name = Bobby's Potion
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion of levitation

f - an emerald potion

Inventory letter = f
No object name
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion
cxname_singular(obj) = emerald potion


l - a smoky potion

Inventory letter = l
No object name
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion
cxname_singular(obj) = smoky potion

with no object name and real name unknown cxname_singular(obj) is right

l - an uncursed potion of levitation

Inventory letter = l
No object name
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion of levitation
cxname_singular(obj) = potion of levitation

with no object name and real name known  cxname_singular(obj) is right

l - an uncursed potion of levitation named My Fav Potion

Inventory letter = l
obj->oextra->oname = My Fav Potion
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion of levitation
cxname_singular(obj) = potion of levitation named My Fav Potion

With named potion obj->oextra->oname is right.

m - the cursed -2 Stormbringer

Inventory letter = m
obj->oextra->oname = Stormbringer
In inventory
object type number = 42
Object class name = runesword
Object class description = runed broadsword
simple_typename(obj->otyp) = runesword
cxname_singular(obj) = Stormbringer

obj->oextra->oname works fine for Artifacts

might work:

char *
autoletter_name_type(obj)
struct obj *obj;
{
    if (has_oname(obj))
        return(obj->oextra->oname);

    return xname_flags(obj, CXN_SINGULAR);
}

o - a lamp

Inventory letter = o
No object name
In inventory
object type number = 204
Object class name = magic lamp
Object class description = lamp
simple_typename(obj->otyp) = lamp
cxname_singular(obj) = lamp
autoletter_name_type(obj) = lamp

o - a cursed magic lamp

Inventory letter = o
No object name
In inventory
object type number = 204
Object class name = magic lamp
Object class description = lamp
simple_typename(obj->otyp) = magic lamp
cxname_singular(obj) = magic lamp
autoletter_name_type(obj) = magic lamp

o - a cursed magic lamp named My Lamp

Inventory letter = o
obj->oextra->oname = My Lamp
In inventory
object type number = 204
Object class name = magic lamp
Object class description = lamp
simple_typename(obj->otyp) = magic lamp
cxname_singular(obj) = magic lamp named My Lamp
autoletter_name_type(obj) = My Lamp

p - a long sword named Frost Brand

Inventory letter = p
obj->oextra->oname = Frost Brand
In inventory
object type number = 37
Object class name = long sword
Object class description = (null)
simple_typename(obj->otyp) = long sword
cxname_singular(obj) = long sword named Frost Brand
autoletter_name_type(obj) = Frost Brand

q - 10 +0 daggers

Inventory letter = q
No object name
In inventory
object type number = 17
Object class name = dagger
Object class description = (null)
simple_typename(obj->otyp) = dagger
cxname_singular(obj) = dagger
autoletter_name_type(obj) = dagger

r - 10 +7 elven daggers.

Inventory letter = r
No object name
In inventory
object type number = 18
Object class name = elven dagger
Object class description = runed dagger
simple_typename(obj->otyp) = elven dagger
cxname_singular(obj) = elven dagger
autoletter_name_type(obj) = elven dagger

s - 5 crude daggers

Inventory letter = s
No object name
In inventory
object type number = 19
Object class name = orcish dagger
Object class description = crude dagger
simple_typename(obj->otyp) = crude dagger
cxname_singular(obj) = crude dagger
autoletter_name_type(obj) = crude dagger

I say it works well enough.

Removing from invent.c

            break;
        }

    /* Bobby Durrett - this might print from object in #adjust command */

    write_debug_file_obj(obj);

    /* initialize the list with all lower and upper case letters */
    lets[GOLD_INDX] = (obj->oclass == COIN_CLASS) ? GOLD_SYM : ' ';


Next I guess go back to 

autoletter_adjust

Add a call to autoletter_name_type to get the name_type of the 
passed inventory object.

Then use 

int
lookup_autoletter(char *object_type_or_name)

to look up the array entry for that object type or name

then just write to the debug file for now

letter
priority

Then find somewhere to stick the call to autoletter_adjust
that makes more sense than new game.

Like when we pick up or wish for an object and it goes into
our inventory.

5/31/2020

I think put autoletter_adjust back in invent.c where the write_debug_file_obj
was before even though it was not where autoletter_adjust should really go just to get 
the lookup working.

Done. Works nicely.

Now figure out a place to put autoletter_adjust so I can really work on adjusting
to a new letter.

cmd.c

/* ordered by command name */
struct ext_func_tab extcmdlist[] = {
    { '#', "#", "perform an extended command",
            doextcmd, IFBURIED | GENERALCMD },
    { M('?'), "?", "list all extended commands",
            doextlist, IFBURIED | AUTOCOMPLETE | GENERALCMD },
    { M('a'), "adjust", "adjust inventory letters",
            doorganize, IFBURIED | AUTOCOMPLETE },
           
Seems like doorganize really is called by #adjust

somewhere in invent.c

    /* inline addinv; insert loose object at beginning of inventory */
    obj->invlet = let;
    obj->nobj = invent;
    obj->where = OBJ_INVENT;
    invent = obj;
    reorder_invent();
    
Maybe inside 

void
assigninvlet(otmp)
register struct obj *otmp;
{

Maybe somewhere in the logic of how to pick a letter I could move the object
to the right letter. But that would only work well if the letter was not already
in use. Could just choose it.

    if (!(obj = getobj(allowall, "adjust")))
        return 0;

I think here in invent.c in doorganize it prompts the user for a letter

maybe like sticky the stuff after here relates to the actual switch.

/* sort the inventory; used by addinv() and doorganize() */
STATIC_OVL void
reorder_invent()

end of addinv( in invent.c
 added:
    addinv_core2(obj);
    carry_obj_effects(obj); /* carrying affects the obj */
    update_inventory();
    return obj;
}

Maybe before update_inventory() call autoletter_adjust(obj)

that way it will be called before every object is added
but before it is displayed.

If an object exists with the right letter swap them
and reorder_invent().

may have to have the swap and reorder function in
invent.c to call local function reorder_invent().

This may only get were new letters are added

May also need a call in doorganize

Maybe right before update_inventory here.

    if (splitting)
        clear_splitobjs(); /* reset splitobj context */
    update_inventory();
    return 0;
}

Or maybe put a check in doorganize to make sure it is not moving
a letter that is set by autoletter.

Then I would only update the letter in addinv.

Try addinv first just to see if it works. Then worry about doorganize

 Armor
 a - an uncursed +2 pair of leather gloves (being worn)
 b - an uncursed +1 robe (being worn)
 Comestibles
 f - 4 uncursed food rations
 g - 5 uncursed apples
 h - 5 uncursed oranges
 i - 3 uncursed fortune cookies
 Scrolls
 d - an uncursed scroll of identify
 Spellbooks
 c - a blessed spellbook of protection
 Potions
 e - 3 uncursed potions of healing
 (end)

pair of fencing gloves not found in autoletter_array
robe not found in autoletter_array
dark blue spellbook not found in autoletter_array
scroll labeled GNIK SISI VLE not found in autoletter_array
swirly potion not found in autoletter_array
potion of healing not found in autoletter_array
potion of healing not found in autoletter_array
food ration not found in autoletter_array
food ration not found in autoletter_array
food ration not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
fortune cookie not found in autoletter_array
fortune cookie not found in autoletter_array
fortune cookie not found in autoletter_array

Each individual object when multiples are added are included
in addinv

wished for key

key found in autoletter_array
letter = k
priority = 1

nothing done when I identified it.

does not do anything when I restore game.

took out of add inv

why not just create a little routine at the bottom of
invent.c that swaps the letters and calls
STATIC_OVL void
reorder_invent()

Then figure out where to put it.

6/5/2020

pickup_object

pickup

pickup.c

Maybe place to test autoletter_adjust

/*
 * Pick up <count> of obj from the ground and add it to the hero's inventory.
 * Returns -1 if caller should break out of its loop, 0 if nothing picked
 * up, 1 if otherwise.
 */
int
pickup_object(obj, count, telekinesis)
struct obj *obj;
long count;
boolean telekinesis; /* not picking it up directly by hand */

/*
 * Do the actual work of picking otmp from the floor or monster's interior
 * and putting it in the hero's inventory.  Take care of billing.  Return a
 * pointer to the object where otmp ends up.  This may be different
 * from otmp because of merging.
 */
struct obj *
pick_obj(otmp)
struct obj *otmp;

Maybe in here?

    result = addinv(otmp);

I thought I looked at addinv.

Maybe put back in addinv and get it
to really work there.

Put back in addinv again.

                         Weapons
                         a - a +0 katana (weapon in hand)
                         b - a +0 wakizashi (alternate weapon; not wielded)
                         c - a +0 yumi
                         d - 44 +0 ya (in quiver)
                         Armor
                         e - an uncursed rustproof +0 splint mail (being worn)
                         Tools
                         f - a key
                         (end)

after wishing for key:

samurai sword not found in autoletter_array
wakizashi not found in autoletter_array
long bow not found in autoletter_array
bamboo arrow not found in autoletter_array
splint mail not found in autoletter_array
key found in autoletter_array
letter = k
priority = 1

commit this and then figure out how to switch to right letter.

6/6/2020

Pretty much works. Can wish for or pick up key and it switches to k.

6/7/2020

want to add bags to my list

objects.c:CONTAINER("sack",           "bag", 0, 0, 0, 35,  15,   2, CLOTH, HI_CLOTH),
objects.c:CONTAINER("oilskin sack",   "bag", 0, 0, 0,  5,  15, 100, CLOTH, HI_CLOTH),
objects.c:CONTAINER("bag of holding", "bag", 0, 1, 0, 20,  15, 100, CLOTH, HI_CLOTH),
objects.c:CONTAINER("bag of tricks",  "bag", 0, 1, 1, 20,  15, 100, CLOTH, HI_CLOTH),


OPTIONS=autoletter:h:bag of holding:1
OPTIONS=autoletter:h:oilskin sack:2
OPTIONS=autoletter:h:sack:3
OPTIONS=autoletter:h:bag:4

bag could be bad - bag of tricks.

new options

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none
OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn
OPTIONS=autoletter:h:bag of holding:1
OPTIONS=autoletter:h:oilskin sack:2
OPTIONS=autoletter:h:sack:3
OPTIONS=autoletter:h:bag:4

