bobbyhack notes

https://www.bobbydurrettdba.com/nethackgame/

nethack@bobbydurrettdba.com

5/23/19

bobbyhack in its current state is some point in the 3.6.2 beta github stream of commits with four of my 
branches merged into it. They are:

tigerfix
silversword
crazyants
building

I have been doing some brainstorming and I want to move forward with bobbyhack as the base branch for 
my own version of nethack. 

At this point the four branches I created are not part of any cohesive plan or adventure but I hope over
time to mold bobbyhack into my own game with some interesting parts to it. Whether I have time to do so
does not matter. Here are some key ideas:

If I want to catch up with newer code from the Dev team create a new branch off of bobbyhack and work out
the merge issues with the new code. Then merge that branch back in.

If I want to work on some new idea make a branch off of bobbyhack and not the main devteam branch (3.6 at this time).
That way I will always be making changes that are compatible with my game. If I ever write something useful I can 
always go back and retrofit the change to be a patch on top of the latest version or the ongoing git stream.

Keep this file in the commits as my notes of what I am doing. If I merge a branch back into bobbyhack it will have 
an updated version of this file. I have taken a similar approach with the repositories that I used for my
Rosetta Code contributions and I like having a log of what I'm doing in a text file on GitHub.

I debated starting bobbyhack over from scratch from the recently released 3.6.2 release but decided to move forward
from bobbyhack as it is today and merge in devteam changes as desired. Also, I thought about not using the four
existing branches because they are not designed to fit into any story or adventure. But, I can always back them out 
later if I decide to not use them. I put time into testing them so I want to keep them in my code.

Last time I rebased bobbyhack and then added in the four branches. I don't really care about rebasing to clean
up the way the commits look. I want to keep my existing bobbyhack commits out there and move forward. I deleted
my rebase.sh script so I would not accidentally redo the rebasing of bobbyhack.

I thought about coming up with some new clever name like Terebynthia or something but I'm already attached to 
bobbyhack so that is another reason to move forward.

I can follow the devteam's latest code in nethack-git repo while keeping bobbyhack in a separate repo.

Probably my first task after creating this notes.txt file will be to try to merge in the 3.6.2 release changes.

5/24/19

Working on merging in the 3.6.2 release changes.

Merged in 3.6.2 updating monst.c to use 3.6.2 queen bee last line.

Deleted Makefiles. Need to redeploy and manually edit for GAME=bobbyhack
and flex and bison.

Looks like 3.6.2 added another field in the MON macro in monst.c.

Picked a number for crazy ants like a giant ant.

Seems to work.

4/28/2020

Working on adding in the 3.6.6 changes.

[bobby@localhost bobbyhack]$ git checkout bobbyhack
Switched to branch 'bobbyhack'
[bobby@localhost bobbyhack]$ view notes.txt
[bobby@localhost bobbyhack]$ pwd
/home/bobby/nethack/bobbyhack
[bobby@localhost bobbyhack]$ git branch add366
[bobby@localhost bobbyhack]$ git checkout add366
Switched to branch 'add366'

bunch of stuff to get this working

cd /home/bobby/nethack/nethack-git
git fetch upstream
git checkout NetHack-3.6
git merge --ff-only upstream/NetHack-3.6
git push

git push --set-upstream origin NetHack-3.6

git branch --set-upstream-to=remotes/upstream/NetHack-3.6

did not seem to be any conflicts. Good be pretty easy.

[bobby@localhost nethack]$ bhbuild.sh

does tags and all

current branch

everything looks good. Not so bad.

5/2/2020

created autoletter branch

5/3/2020

Created a simple function to write a string to a debugging file.

File is /home/bobby/nethack/debugfile.log

Function is write_debug_file(char *string) in files.c.

Can use it anywhere.

Could create formatted front ends to write_debug_file like

write_debug_file_int(char *format,int data)

int snprintf(formatted_string, 80, format, data);

If formats to more than 80 characters abort.

Could do one for each type we might need. Not sure yet what those would be.

debug functions are up to these now: (in extern.h)

/* Bobby Durrett debug file functions */

E void write_debug_file(char *string);
E void write_debug_file_datetime();
E void write_debug_file_str(char *format,char *data);
E void write_debug_file_int(char *format,int data);

could clone write_debug_file_str or write_debug_file_int for other types
just passes one parameter into format string. should be ok for debugging.

possible other types for debug:

    unsigned oeaten;        /* nutrition left in food, if partly eaten */
    long age;               /* creation date */
    short otyp; /* object class number */
    schar spe; /* quality of weapon, weptool, armor or ring (+ or -);
    xchar ox, oy;
    Bitfield(cursed, 1);


typedef signed char schar;

https://vim.fandom.com/wiki/Browsing_programs_with_tags

typedef schar xchar;

looks like we need short, long, char.

unsigned can work with int

https://en.wikipedia.org/wiki/C_data_types

Looks like long would be helpful. Others can adjust.

added

E void write_debug_file_long(char *format,long data);

5/4/2020

Cleaned up the debug file stuff a little bit.

Put test code in /home/bobby/debugfile

5/9/2020

Poking around.

boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;

in options.c

I think it is called for each option in .nethackrc

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none


boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;
{
    write_debug_file_str("In parseoptions opts = %s\n",opts);


[bobby@localhost debugfile]$ cat /dev/null > debugfile.log;tail -f debugfile.log
In parseoptions opts = noshowexp,showscore,time,color,!autopickup
In parseoptions opts = showscore,time,color,!autopickup
In parseoptions opts = time,color,!autopickup
In parseoptions opts = color,!autopickup
In parseoptions opts = !autopickup
In parseoptions opts = autodig,ibmgraphics,autoquiver,noautoopen
In parseoptions opts = ibmgraphics,autoquiver,noautoopen
In parseoptions opts = autoquiver,noautoopen
In parseoptions opts = noautoopen
In parseoptions opts = number_pad:0,msg_window:reversed
In parseoptions opts = msg_window:reversed
In parseoptions opts = hilite_pet,hilite_pile,pickup_burden:unencumbered
In parseoptions opts = hilite_pile,pickup_burden:unencumbered
In parseoptions opts = pickup_burden:unencumbered
In parseoptions opts = disclose:yi ya yv yg yc yo
In parseoptions opts = boulder:`
In parseoptions opts = sortloot:none

Looks like it just processes the first option passed to it.

    if ((op = index(opts, ',')) != 0) {
        *op++ = 0;
        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

I guess this sticks a 0 where the first comma is so the rest of the function
can use opts as if it didn't have a comma.

Then it calls itself with op pointing to the string after the comma.

[bobby@localhost src]$ grep parseoptions *.c
files.c:        ++bufp; /* skip '='; parseoptions() handles spaces */
files.c:        if (!parseoptions(bufp, TRUE, TRUE))
options.c:             * parseoptions() will check each individually
options.c:            (void) parseoptions(opts, TRUE, FALSE);
options.c:/* paranoia[] - used by parseoptions() and special_handling() */
options.c:parseoptions(opts, tinitial, tfrom_file)
options.c:        if (!parseoptions(op, initial, from_file))
options.c:         * or prompt for new values. In most cases, call parseoptions()
options.c:                (void) parseoptions(buf, setinitial, fromfile);
options.c:                    (void) parseoptions(buf, setinitial, fromfile);
options.c:        /* parseoptions will prompt for the list of types */
options.c:        (void) parseoptions(strcpy(buf, "pickup_types"),
vision.c: *      + After an option has changed that affects vision [parseoptions()]

Mostly return value is ignored except in files.c.

        if (!parseoptions(bufp, TRUE, TRUE))
            retval = FALSE;

this uses returned value in files.c
in function 

boolean
parse_config_line(origbuf)
char *origbuf;

But what the heck is parse_config_line doing?

boolean
parse_config_line(origbuf)
char *origbuf;
{
    write_debug_file_str("In parse_config_line origbuf = %s\n",origbuf);


clear; cat /dev/null > debugfile.log;tail -f debugfile.log

In parse_config_line origbuf = WIZARDS=bobby
In parse_config_line origbuf = EXPLORERS=*
In parse_config_line origbuf = MAXPLAYERS=10
In parse_config_line origbuf = GDBPATH=/usr/bin/gdb
In parse_config_line origbuf = GREPPATH=/bin/grep
In parse_config_line origbuf = PANICTRACE_GDB=1
In parse_config_line origbuf = PANICTRACE_LIBC=2
More than MAX_LINE_SIZE character string in write_debug_file_str
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=number_pad:0,msg_window:reversed
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=disclose:yi ya yv yg yc yo
In parse_config_line origbuf = OPTIONS=boulder:`
In parse_config_line origbuf = OPTIONS=sortloot:none

I guess these are the uncommented lines in sysconf as well as the .nethackrc

[bobby@localhost nethack]$ grep = /home/bobby/nethack/games/lib/bobbyhackdir/sysconf | grep -v \#
WIZARDS=bobby
EXPLORERS=*
MAXPLAYERS=10
GDBPATH=/usr/bin/gdb
GREPPATH=/bin/grep
PANICTRACE_GDB=1
PANICTRACE_LIBC=2

I'm thinking autoletter should be an option since it is related to game
play and not configuration of the system relative to Linux.

5/10/2020

[bobby@localhost ~]$ diff .nethackrc .nethackrc.workingsave

.nethackrc.workingsave is my normal options for nethack 3.6.x

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=autoletter:blindfold:1

simple test of one autoletter option.

[bobby@localhost ~]$ bobbyhack -D

OPTIONS=autoletter:blindfold:1
 * Line 1: Unknown option 'autoletter:blindfold:1'.

1 error in /home/bobby/.nethackrc.


Hit return to continue:

probably here

[bobby@localhost src]$ grep "Unknown option" *.c
options.c:    config_error_add("Unknown option '%s'", opts);

    /* out of valid options */
    config_error_add("Unknown option '%s'", opts);
    return FALSE;
}

this is called if you fall through to this point.

This is the end of parseoptions in options.c

Maybe add the autoletter support here.

/* compound options, for option_help() and external programs like Amiga
 * frontend */
static struct Comp_Opt {
    const char *name, *descr;
    int size; /* for frontends and such allocating space --
               * usually allowed size of data in game, but
               * occasionally maximum reasonable size for
               * typing when game maintains information in
               * a different format */
    int optflags;
} compopt[] = {
    { "align", "your starting alignment (lawful, neutral, or chaotic)", 8,
      DISP_IN_GAME },
    { "align_message", "message window alignment", 20, DISP_IN_GAME }, /*WC*/
    { "align_status", "status window alignment", 20, DISP_IN_GAME },   /*WC*/

Seems like we may not need to add autoletter to compopt[] in options.c at first just to get it working
but later to add it to the help for options.

Probably just need to handle autoletter at the end of parseoptions for now.

    /* control over whether highlights should be displayed, and for how long */
    fullname = "statushilites";
    if (match_optname(opts, fullname, 9, TRUE)) {
#ifdef STATUS_HILITES
        if (negated) {
            iflags.hilite_delta = 0L;
        } else {
            op = string_for_opt(opts, TRUE);
            iflags.hilite_delta = (op == empty_optstr || !*op) ? 3L : atol(op);
            if (iflags.hilite_delta < 0L)
                iflags.hilite_delta = 1L;
        }
        if (!tfrom_file)
            reset_status_hilites();
        return retval;
#else
        config_error_add("'%s' is not supported", fullname);
        return FALSE;
#endif
    }

possible example. could use fullname = "autoletter";

Not sure if I should use something like

#ifdef AUTOLETTER to bracket the code? Kind of gross.

If I am going to do it I should do something like

#ifdef DEBUG_FILE for the debugging code.

I think retval is set by the earlier recursive call

        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

So if current option is good return retval otherwise
return FALSE.

5/19/2020

in options.c

/* check whether a user-supplied option string is a proper leading
   substring of a particular option name; option string might have
   a colon or equals sign and arbitrary value appended to it */
boolean
match_optname(user_string, opt_name, min_length, val_allowed)
const char *user_string, *opt_name;
int min_length;
boolean val_allowed;

I guess use this:

    /* automatically set objects to a specific letter */
    fullname = "autoletter";
    if (match_optname(opts, fullname, 10, TRUE)) {
        write_debug_file_str("autoletter opts = %s\n",opts);
        return retval;
    }
    
[bobby@localhost ~]$ cat .nethackrc
OPTIONS=autoletter:blindfold:1

debug output:

autoletter opts = autoletter:blindfold:1

switched to 7 letters so autolet works.

autoletter opts = autoletter:blindfold:1
autoletter opts = autolet:blindfold:1
autoletter opts = autoletter:blindfold:1

Duh.

should be like this

autoletter opts = autoletter:b:blindfold:1

letter:object type or name:integer priority


void
add_autoletter(char *opts)
{
    write_debug_file_str("In add_autoletter opts = %s\n",opts);
}

shell of where to do actual insert into data structure

strchr to find a string

need to add validation code in add_autoletter
to make sure isn't a huge string et. al. and that
it has the proper number of :'s and all.
Also having it default to priority 1 without the last
: and having a prefix for autoletter.

might need config_error_add and similar routines
to report an error

/* varargs 'config_error_add()' moved to pline.c */

config_error_add("Unknown %s '%s'", fullname, op);

5/20/2020

add_autoletter is parsing out the autoletter option
pretty well with error checking.

getting super annoying clock skew message need to figure
out how to sync Linux VM clock with my Windows laptop host.
Maybe part of tools for virtualbox?

should I put this code in its own function and call
it from add_autoletter?

maybe parse_autoletter?

5/23/2020

was getting weird time skew errors until I realized that my
Windows 10 laptop was the one that was out of sync somehow.

Had to go to Date and time settings and click on
Sync now button to resolve.

Moved autoletter option parsing code into
parse_autoletter to keep add_autoletter
cleaner.

5/25/2020

Need to save in an array now.

boolean
insert_autoletter(char letter,char *object_type_or_name, int priority)

I guess since the array is static and the debug file commands are in files.c
I cannot write a debug print command to directly access the array.

I could write interface functions to get num_autoletter and
a specific element of the array.

int num_autoletter()

boolean get_autoletter(int index,char *letter,char *object_type_or_name, int *priority)

then I could write 

void
write_debug_file_autoletter()

to dump the entire array in a nicely formatted output.

Could test with my entire option list as I want to use it

(blindfold, lamp, etc.)

Need to test all the bad cases such as

not a alpha letter

priority < 1

also need to add a check for duplicate object type or name.
and make sure there is a meaningful error message.

should I add config error messages to insert_autoletter
itself.

maybe create

int lookup_autoletter(char *object_type_or_name)

returns index into array >= 0 < MAX_AUTO_OPTIONS

then combine with get_autoletter to return actual values.

that way get_autoletter can be used to interate through
entire array and to pull data back for a looked up
index

not sure it makes sense to call config_error_add
in insert_autoletter. may have to move out if I end up
calling insert_autoletter from somewhere else
such as users changing options on the fly.

I wonder if here:

    if (!parse_autoletter(opts,&letter,object_type_or_name,&priority))
        return FALSE;

    return insert_autoletter(letter, object_type_or_name, priority);

I should make both calls - parse_autoletter and insert_autoletter
return an error string and call config_error_add within add_autoletter.

top level add_autoletter could be like

add_autoletter_config

to indicate it is from config file.

That would keep parse_autoletter and insert_autoletter available for
non-config-file uses.

But then again if users adjusted the config in the program would probably 
not use parse_autoletter.

could have a wrapper to insert_autoletter called 
insert_autoletter_config that did the error writing.

Not sure.

or just stick with this as only from the config file for now.
It really does not need to change in the middle of the game.

write these next:

int num_autoletter()

boolean get_autoletter(int index,char *letter,char *object_type_or_name, int *priority)

void write_debug_file_autoletter()

stick in extern.h

add debug to write out opts in add_autoletter and the call
write_debug_file_autoletter at the end.

maybe

    return insert_autoletter(letter, object_type_or_name, priority);

change to

    if (!insert_autoletter(letter, object_type_or_name, priority))
        return FALSE;
        
    write_debug_file_autoletter()
    
    return TRUE;

Then I could really see the options loading into the array.

boolean
add_autoletter(char *opts)
{
    /* parsed option details */
    char letter;
    char object_type_or_name[MAX_OBJ_TYPE_NAME_LEN];
    int priority;

    write_debug_file_str("In add_autoletter opts = %s" ,opts);

    if (!parse_autoletter(opts,&letter,object_type_or_name,&priority))
        return FALSE;

    if (!insert_autoletter(letter, object_type_or_name, priority))
        return FALSE;

    write_debug_file_autoletter();

    return TRUE;
}

Now that this is there.

Maybe do more testing to make sure array is updated correctly.

Try my really intended options for one thing.

OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn


It looks like in the code they call oil lamp the name
and lamp the description.

I have been thinking of these as "object types"

names are in objects.c

In add_autoletter opts = autoletter:u:unicorn horn

Autoletter array length = 13

Inventory Letter     Object Type or Name                     Priority
---------------------------------------------------------------------
b                    blindfold                                      1
l                    magic lamp                                     1
l                    lamp                                           2
l                    oil lamp                                       2
l                    brass lantern                                  2
k                    key                                            1
k                    skeleton key                                   1
m                    mirror                                         1
m                    looking glass                                  1
w                    magic whistle                                  1
w                    whistle                                        2
p                    pick-axe                                       1
u                    unicorn horn                                   1

My full options:

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none
OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn

[bobby@localhost ~]$

8:52 PM

Next steps.

1 - need to go over my handwritten notes to see what I was thinking.

2 - I think I need to identify where objects are brought into the 
main inventory. My notebook had a list of ideas for this.
- game startup
- picking up object
- wishing for object
- taking out of a container
need to check my list.

3 - at those points call an autoletter routine for each object that
enters my inventory. That routine will look up the name or type of the
object in the array and return the letter it should switch to if any.

4 - once I identify which objects need to switch do the switch.
Maybe look at the preadjust and sticky code for ideas?
Maybe the #adjust code has the switch in it?

Could start with a stub that just writes to the debug file that 
we got there. Put it in the places identified by 2?

maybe call the stub autoletter_adjust and pass a pointer to the
object itself.

Ultimately all the code for 3 and 4 would be in autoletter_adjust.

Could start with a stub that prints the object information
such as its type, description, name, etc.

Put it in the locations from 2.

Then add the code to see if the object needs its inventory letter adjusted
which is 3.

The add the code to actually do the switch. (4.)

***********************************************************************************

NEXT STEP:

Write the autoletter_adjust([object type] *) stub with debug file outputs
for the object passed to it and
put it in places where objects come into the main inventory. Test. 

***********************************************************************************

5/27/2020

Need to put autoletter_adjust somewhere where I have an object pointer.

Look at preadjust

[bobby@localhost src]$ grep PREADJUST *.c
allmain.c:#ifdef PREADJUST
allmain.c:#endif /* PREADJUST */
files.c:#ifdef PREADJUST
files.c:        } else if (match_varname(buf, "PREADJUST", 6)) {
files.c:#endif /* PREADJUST */
invent.c:#ifndef PREADJUST
invent.c:#endif /* PREADJUST */
invent.c:#ifndef PREADJUST
invent.c:#endif /* PREADJUST */
invent.c:#ifdef PREADJUST
invent.c:#endif /* PREADJUST */
invent.c:#ifndef PREADJUST
invent.c:#endif /* PREADJUST */
options.c:#ifdef PREADJUST
options.c:#endif /* PREADJUST */
options.c:#ifdef PREADJUST
options.c:#endif /* PREADJUST */
restore.c:#ifdef PREADJUST
restore.c:#endif /* PREADJUST */


allmain.c

void
newgame()
{

#ifdef PREADJUST
	apply_preadjust();
	cleanup_preadjust();
#endif /* PREADJUST */

invent.c

int
doorganize()

options.c 

code here like in mine

void
apply_preadjust()
{
    int i;
    struct obj *obj;

    if (n_preadjust == 0)
	return;
    /* this is kind of expensive, I suppose, but it only happens once */
    for (i = 0; i < n_preadjust; i++) {
	for (obj = invent; obj; obj = obj->nobj) {
	    if (strstri(OBJ_NAME(objects[obj->otyp]), preadj_list[i].descr)) {
# ifdef STICKY_OBJECTS
		obj->sticky = preadj_list[i].sticky;
# endif /* STICKY_OBJECTS */
		doorganize_guts(obj, preadj_list[i].invlet, TRUE);
		break;
	    }
	}
    }
}

seems like this goes through the initial inventory
and readjusts it.

called from newgame()

could loop through the inventory in the same way
and call autoletter_adjust for each object.

would mean that autoletter_adjust operates on objects
after they are already put in the inventory.

obj.h

struct obj {

    char invlet;    /* designation in inventory */

    xchar where;        /* where the object thinks it is */

#define OBJ_INVENT 3    /* object in the hero's inventory */

should be where == OBJ_INVENT

struct oextra {
    char *oname;          /* ptr to name of object */

    struct oextra *oextra; /* pointer to oextra struct */

    Bitfield(known, 1);     /* exact nature known */
    Bitfield(dknown, 1);    /* color or text known */
    Bitfield(bknown, 1);    /* blessing or curse known */
    Bitfield(rknown, 1);    /* rustproof or not known */
    
might be relevant

need object description or name

onames.h has the otyp numbers

#define	DWARVISH_IRON_HELM	74

where are the names stored?

[bobby@localhost src]$ grep "small shield" *.c
objects.c:SHIELD("small shield", None,

 * The data in this file is processed twice, to construct two arrays.

and the array names are...?

NEARDATA struct objdescr obj_descr[] =

NEARDATA struct objclass objects[] =

maybe these two?

[bobby@localhost src]$ grep "obj_descr\[" *.c
do_name.c:                 : obj_descr[STRANGE_OBJECT].oc_name);
objects.c: * struct objdescr obj_descr[] =
objects.c:NEARDATA struct objdescr obj_descr[] =
options.c:    obj_descr[SLIME_MOLD].oc_name = "fruit";
pager.c:                              : an(obj_descr[STRANGE_OBJECT].oc_name));
pager.c:                     : obj_descr[STRANGE_OBJECT].oc_name);

in objclass.h

struct objdescr {
    const char *oc_name;  /* actual name */
    const char *oc_descr; /* description when name unknown */
};


void
autoletter_adjust(struct obj *obj)
{
    if (obj != NULL)
        write_debug_file_char("Inventory letter = %c\n",obj->invlet);
    else
        return;

    if (has_oname(obj))
        write_debug_file_str("Object name = %s\n",obj->oextra->oname);
    else
        write_debug_file("No object name\n");

    if (obj->where == OBJ_INVENT)
        write_debug_file("In inventory\n");
    else
        write_debug_file("Not in inventory\n");

    write_debug_file_int("object type number = %d\n",obj->otyp);

    write_debug_file_str("Object class name = %s\n",(char *)obj_descr[obj->otyp].oc_name);

    write_debug_file_str("Object class description = %s\n",(char *)obj_descr[obj->otyp].oc_descr);
}

shows the different types

probably could use these different fields and maybe some of the bitfields to figure out if the
object has a user given name and if the user knows the official name.

Some of this is stiff fuzzy like this one for potion of sickness:

Inventory letter = d
No object name
In inventory
object type number = 294
Object class name = sickness
Object class description = fizzy

Need to find the code that builds the full name potion of sickness, fizzy potion, etc.

5/29/2020

started putting object debugging code in
write_debug_file_obj(obj);

Need to get the full object name like

spellbook of remove curse

instead of

remove curse

sidetracked

in zap.c

        /* if type already discovered, treat this item has having been seen
           even if hero is currently blinded (skips redundant makeknown) */
        if (objects[obj->otyp].oc_name_known) {

Looks like if objects[obj->otyp].oc_name_known is true then you know the 
true name.

this whole routine in zap.c looks interesting

/* wand discovery gets special handling when hero is blinded */
void
learnwand(obj)
struct obj *obj;
{
    /* For a wand (or wand-like tool) zapped by the player, if the
       effect was observable (determined by caller; usually seen, but
       possibly heard or felt if the hero is blinded) then discover the
       object type provided that the object itself is known (as more
       than just "a wand").  If object type is already discovered and
       we observed the effect, mark the individual wand as having been
       seen.  Suppress spells (which use fake spellbook object for `obj')
       so that casting a spell won't re-discover its forgotten book. */
    if (obj->oclass != SPBOOK_CLASS) {
        /* if type already discovered, treat this item has having been seen
           even if hero is currently blinded (skips redundant makeknown) */
        if (objects[obj->otyp].oc_name_known) {
            obj->dknown = 1; /* will usually be set already */

        /* otherwise discover it if item itself has been or can be seen */
        } else {
            /* in case it was picked up while blind and then zapped without
               examining inventory after regaining sight (bypassing xname) */
            if (!Blind)
                obj->dknown = 1;
            /* make the discovery iff we know what we're manipulating */
            if (obj->dknown)
                makeknown(obj->otyp);
        }
        update_inventory();
    }
}

I guess obj->dknown is true if a specific object is know and
objects[obj->otyp].oc_name_known is true if the class of object
is known.

invent.c

void
update_inventory()
{
    if (restoring)
        return;

    /*
     * Ought to check (windowprocs.wincap2 & WC2_PERM_INVENT) here....
     *
     * We currently don't skip this call when iflags.perm_invent is False
     * because curses uses that to disable a previous perm_invent window
     * (after toggle via 'O'; perhaps the options code should handle that).
     */
    (*windowprocs.win_update_inventory)();
}

so need to find the win_update_inventory for tty I guess.
can't find it.

int
doorganize() /* inventory organizer by Del Lamb */

I think was modified in sticky

invent.c

objname.c

xname?

char *
xname(obj)
struct obj *obj;
{
    return xname_flags(obj, CXN_NORMAL);
}

maybe this

STATIC_OVL char *
xname_flags(obj, cxn_flags)
register struct obj *obj;
unsigned cxn_flags; /* bitmask of CXN_xxx values */
{
    register char *buf;
    register int typ = obj->otyp;
    register struct objclass *ocl = &objects[typ];
    int nn = ocl->oc_name_known, omndx = obj->corpsenm;
    const char *actualn = OBJ_NAME(*ocl);
    const char *dn = OBJ_DESCR(*ocl);
    const char *un = ocl->oc_uname;
    boolean pluralize = (obj->quan != 1L) && !(cxn_flags & CXN_SINGULAR);
    
maybe if I find the right cxn_flags values
I can get what I want.

files.c: In function ‘write_debug_file_obj’:
files.c:4850:64: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
     write_debug_file_str("xname_flags(obj, CXN_NORMAL) = %s\n",(char *)xname_flags(obj, CXN_NORMAL));

I guess the STATIC_OVL keeps you from using it.

/* like cxname, but ignores quantity */
char *
cxname_singular(obj)
struct obj *obj;

Inventory letter = h
No object name
In inventory
object type number = 281
Object class name = invisibility
Object class description = brilliant blue
cxname_singular(obj) = potion of invisibility

converts the full potion name.

I need to find a different place to put the call to 
write_debug_file_obj so I can try one object at a time
of my choosing. right now now I have it in newgame where
I am calling autoletter_adjust a bunch of times.

Looking at other code it seems to be more compact.
Probably trying to fit a lot of code in a more compact file
without commenting every line. :)

I can't really work on the object name stuff
until I can work on an object of my choosing.

5/30/2020

Think about what to do with objects that stack.

10 potions of holy water

10 +2 daggers

I am really thinking more about tools but need to handle other cases
or maybe not at first.

Maybe only accept tools at first.

Taking this out of allmain.c

    u_init();

    /* Bobby Durrett - added to apply autoletter options after
       initial setup. Pieces of code taken from Preadjust patch */

    struct obj *obj;

    /* loop through the objects in the newly created inventory */

    for (obj = invent; obj; obj = obj->nobj)
        autoletter_adjust(obj);

#ifndef NO_SIGNAL
    (void) signal(SIGINT, (SIG_RET_TYPE) done1);
#endif

Can always put back.

Need somewhere else to put write_debug_file_obj(obj)

invent.c

    /* Bobby Durrett - this might print from object in #adjust command */
        
    write_debug_file_obj(obj);

Inventory letter = e
No object name
In inventory
object type number = 198
Object class name = lock pick
Object class description = (null)
cxname_singular(obj) = lock pick

Worked.

So from letter will cause the object to go
to write_debug_file_obj and we can use that to experiment with
object names and what is known and unknown.

So if you look at a typical inventory

                        $ - 1695 gold pieces
                        Weapons
                        a - a +0 scalpel (weapon in hand)
                        Armor
                        b - an uncursed +1 pair of leather gloves (being worn)
                        Comestibles
                        k - 7 uncursed apples
                        Spellbooks
                        h - a blessed spellbook of healing
                        i - a blessed spellbook of extra healing
                        j - a blessed spellbook of stone to flesh
                        Potions
                        d - 3 uncursed potions of healing
                        e - a blessed potion of healing
                        f - 4 uncursed potions of extra healing
                        Wands
                        g - a wand of sleep (0:7)
                        Tools
                        c - an uncursed stethoscope


what I want in the autoletter array is the name without all the extra stuff

Singular without "a" or the number of items.

No b/u/c status.

No +1.

No rustproof etc.

Also for unknown items the unknown name

i.e. 

a fizzy potion 

would be 

fizzy potion

a scroll labeled PHOL ENDE WODAN.

would be

scroll labeled PHOL ENDE WODAN

n - a crystal wand.

wb

crystal wand

Artifacts and named objects:

p - the blessed +3 Frost Brand

wb

Frost Brand

a - a +0 scalpel named My Favorite Weapon (weapon in hand)

wb

My Favorite Weapon

the idea is that when an item enters my inventory it would look up this stripped down name in the 
autoletter array based on this order of priority (autoletter name)

1. Name of object - a name I gave it or an artifact name.

2. Unknown type - generic type like key or fizzy potion

3. Fully known type spellbook of healing

The rest of the object characteristics such as b/u/c, enchantment level, number of items, rustproof
would give it priority over an existing object of the same type. The priority number would help 
distinguish between multiple object_name_or_type values for the same letter,
but these characteristics would break the tie if there were multiple objects in the inventory with the 
same "autoletter name"

But first I need to figure out how to get the base name to poll the array with so I can use
write_debug_file_obj to figure that out and then make a function in objects.c that returns
the name for autoletter use.

a - a +0 battle-axe named My Axe (weapon in hands)

Inventory letter = a
Object name = My Axe
In inventory
object type number = 28
Object class name = battle-axe
Object class description = double-headed axe
cxname_singular(obj) = battle-axe named My Axe

cxname_singular is not it.

c - 56 +2 arrows (in quiver)

Inventory letter = c
No object name
In inventory
object type number = 1
Object class name = arrow
Object class description = (null)

Object class name works.

try a potion

g - an uncursed potion of enlightenment named My Potion

Inventory letter = g
Object name = My Potion
In inventory
object type number = 286
Object class name = enlightenment
Object class description = swirly

how do I get

swirly potion

potion of enlightenment

Cannot use xname_flags because it sticks in
the user supplied name.

hack.h

/* bitmask flags for corpse_xname();
   PFX_THE takes precedence over ARTICLE, NO_PFX takes precedence over both */
#define CXN_NORMAL 0    /* no special handling */
#define CXN_SINGULAR 1  /* override quantity if greather than 1 */
#define CXN_NO_PFX 2    /* suppress "the" from "the Unique Monst */
#define CXN_PFX_THE 4   /* prefix with "the " (unless pname) */
#define CXN_ARTICLE 8   /* include a/an/the prefix */
#define CXN_NOCORPSE 16 /* suppress " corpse" suffix */

Does not seem to be a way to get rid of it.

Of course we could just not use it if we have the name.

try

char *
simple_typename(otyp)

f - a cursed potion of levitation named Bobby's Potion

Inventory letter = f
Object name = Bobby's Potion
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion of levitation

f - an emerald potion

Inventory letter = f
No object name
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion
cxname_singular(obj) = emerald potion


l - a smoky potion

Inventory letter = l
No object name
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion
cxname_singular(obj) = smoky potion

with no object name and real name unknown cxname_singular(obj) is right

l - an uncursed potion of levitation

Inventory letter = l
No object name
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion of levitation
cxname_singular(obj) = potion of levitation

with no object name and real name known  cxname_singular(obj) is right

l - an uncursed potion of levitation named My Fav Potion

Inventory letter = l
obj->oextra->oname = My Fav Potion
In inventory
object type number = 279
Object class name = levitation
Object class description = cyan
simple_typename(obj->otyp) = potion of levitation
cxname_singular(obj) = potion of levitation named My Fav Potion

With named potion obj->oextra->oname is right.

m - the cursed -2 Stormbringer

Inventory letter = m
obj->oextra->oname = Stormbringer
In inventory
object type number = 42
Object class name = runesword
Object class description = runed broadsword
simple_typename(obj->otyp) = runesword
cxname_singular(obj) = Stormbringer

obj->oextra->oname works fine for Artifacts

might work:

char *
autoletter_name_type(obj)
struct obj *obj;
{
    if (has_oname(obj))
        return(obj->oextra->oname);

    return xname_flags(obj, CXN_SINGULAR);
}

o - a lamp

Inventory letter = o
No object name
In inventory
object type number = 204
Object class name = magic lamp
Object class description = lamp
simple_typename(obj->otyp) = lamp
cxname_singular(obj) = lamp
autoletter_name_type(obj) = lamp

o - a cursed magic lamp

Inventory letter = o
No object name
In inventory
object type number = 204
Object class name = magic lamp
Object class description = lamp
simple_typename(obj->otyp) = magic lamp
cxname_singular(obj) = magic lamp
autoletter_name_type(obj) = magic lamp

o - a cursed magic lamp named My Lamp

Inventory letter = o
obj->oextra->oname = My Lamp
In inventory
object type number = 204
Object class name = magic lamp
Object class description = lamp
simple_typename(obj->otyp) = magic lamp
cxname_singular(obj) = magic lamp named My Lamp
autoletter_name_type(obj) = My Lamp

p - a long sword named Frost Brand

Inventory letter = p
obj->oextra->oname = Frost Brand
In inventory
object type number = 37
Object class name = long sword
Object class description = (null)
simple_typename(obj->otyp) = long sword
cxname_singular(obj) = long sword named Frost Brand
autoletter_name_type(obj) = Frost Brand

q - 10 +0 daggers

Inventory letter = q
No object name
In inventory
object type number = 17
Object class name = dagger
Object class description = (null)
simple_typename(obj->otyp) = dagger
cxname_singular(obj) = dagger
autoletter_name_type(obj) = dagger

r - 10 +7 elven daggers.

Inventory letter = r
No object name
In inventory
object type number = 18
Object class name = elven dagger
Object class description = runed dagger
simple_typename(obj->otyp) = elven dagger
cxname_singular(obj) = elven dagger
autoletter_name_type(obj) = elven dagger

s - 5 crude daggers

Inventory letter = s
No object name
In inventory
object type number = 19
Object class name = orcish dagger
Object class description = crude dagger
simple_typename(obj->otyp) = crude dagger
cxname_singular(obj) = crude dagger
autoletter_name_type(obj) = crude dagger

I say it works well enough.

Removing from invent.c

            break;
        }

    /* Bobby Durrett - this might print from object in #adjust command */

    write_debug_file_obj(obj);

    /* initialize the list with all lower and upper case letters */
    lets[GOLD_INDX] = (obj->oclass == COIN_CLASS) ? GOLD_SYM : ' ';


Next I guess go back to 

autoletter_adjust

Add a call to autoletter_name_type to get the name_type of the 
passed inventory object.

Then use 

int
lookup_autoletter(char *object_type_or_name)

to look up the array entry for that object type or name

then just write to the debug file for now

letter
priority

Then find somewhere to stick the call to autoletter_adjust
that makes more sense than new game.

Like when we pick up or wish for an object and it goes into
our inventory.

5/31/2020

I think put autoletter_adjust back in invent.c where the write_debug_file_obj
was before even though it was not where autoletter_adjust should really go just to get 
the lookup working.

Done. Works nicely.

Now figure out a place to put autoletter_adjust so I can really work on adjusting
to a new letter.

cmd.c

/* ordered by command name */
struct ext_func_tab extcmdlist[] = {
    { '#', "#", "perform an extended command",
            doextcmd, IFBURIED | GENERALCMD },
    { M('?'), "?", "list all extended commands",
            doextlist, IFBURIED | AUTOCOMPLETE | GENERALCMD },
    { M('a'), "adjust", "adjust inventory letters",
            doorganize, IFBURIED | AUTOCOMPLETE },
           
Seems like doorganize really is called by #adjust

somewhere in invent.c

    /* inline addinv; insert loose object at beginning of inventory */
    obj->invlet = let;
    obj->nobj = invent;
    obj->where = OBJ_INVENT;
    invent = obj;
    reorder_invent();
    
Maybe inside 

void
assigninvlet(otmp)
register struct obj *otmp;
{

Maybe somewhere in the logic of how to pick a letter I could move the object
to the right letter. But that would only work well if the letter was not already
in use. Could just choose it.

    if (!(obj = getobj(allowall, "adjust")))
        return 0;

I think here in invent.c in doorganize it prompts the user for a letter

maybe like sticky the stuff after here relates to the actual switch.

/* sort the inventory; used by addinv() and doorganize() */
STATIC_OVL void
reorder_invent()

end of addinv( in invent.c
 added:
    addinv_core2(obj);
    carry_obj_effects(obj); /* carrying affects the obj */
    update_inventory();
    return obj;
}

Maybe before update_inventory() call autoletter_adjust(obj)

that way it will be called before every object is added
but before it is displayed.

If an object exists with the right letter swap them
and reorder_invent().

may have to have the swap and reorder function in
invent.c to call local function reorder_invent().

This may only get were new letters are added

May also need a call in doorganize

Maybe right before update_inventory here.

    if (splitting)
        clear_splitobjs(); /* reset splitobj context */
    update_inventory();
    return 0;
}

Or maybe put a check in doorganize to make sure it is not moving
a letter that is set by autoletter.

Then I would only update the letter in addinv.

Try addinv first just to see if it works. Then worry about doorganize

 Armor
 a - an uncursed +2 pair of leather gloves (being worn)
 b - an uncursed +1 robe (being worn)
 Comestibles
 f - 4 uncursed food rations
 g - 5 uncursed apples
 h - 5 uncursed oranges
 i - 3 uncursed fortune cookies
 Scrolls
 d - an uncursed scroll of identify
 Spellbooks
 c - a blessed spellbook of protection
 Potions
 e - 3 uncursed potions of healing
 (end)

pair of fencing gloves not found in autoletter_array
robe not found in autoletter_array
dark blue spellbook not found in autoletter_array
scroll labeled GNIK SISI VLE not found in autoletter_array
swirly potion not found in autoletter_array
potion of healing not found in autoletter_array
potion of healing not found in autoletter_array
food ration not found in autoletter_array
food ration not found in autoletter_array
food ration not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
apple not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
orange not found in autoletter_array
fortune cookie not found in autoletter_array
fortune cookie not found in autoletter_array
fortune cookie not found in autoletter_array

Each individual object when multiples are added are included
in addinv

wished for key

key found in autoletter_array
letter = k
priority = 1

nothing done when I identified it.

does not do anything when I restore game.

took out of add inv

why not just create a little routine at the bottom of
invent.c that swaps the letters and calls
STATIC_OVL void
reorder_invent()

Then figure out where to put it.

6/5/2020

pickup_object

pickup

pickup.c

Maybe place to test autoletter_adjust

/*
 * Pick up <count> of obj from the ground and add it to the hero's inventory.
 * Returns -1 if caller should break out of its loop, 0 if nothing picked
 * up, 1 if otherwise.
 */
int
pickup_object(obj, count, telekinesis)
struct obj *obj;
long count;
boolean telekinesis; /* not picking it up directly by hand */

/*
 * Do the actual work of picking otmp from the floor or monster's interior
 * and putting it in the hero's inventory.  Take care of billing.  Return a
 * pointer to the object where otmp ends up.  This may be different
 * from otmp because of merging.
 */
struct obj *
pick_obj(otmp)
struct obj *otmp;

Maybe in here?

    result = addinv(otmp);

I thought I looked at addinv.

Maybe put back in addinv and get it
to really work there.

Put back in addinv again.

                         Weapons
                         a - a +0 katana (weapon in hand)
                         b - a +0 wakizashi (alternate weapon; not wielded)
                         c - a +0 yumi
                         d - 44 +0 ya (in quiver)
                         Armor
                         e - an uncursed rustproof +0 splint mail (being worn)
                         Tools
                         f - a key
                         (end)

after wishing for key:

samurai sword not found in autoletter_array
wakizashi not found in autoletter_array
long bow not found in autoletter_array
bamboo arrow not found in autoletter_array
splint mail not found in autoletter_array
key found in autoletter_array
letter = k
priority = 1

commit this and then figure out how to switch to right letter.

6/6/2020

Pretty much works. Can wish for or pick up key and it switches to k.

6/7/2020

want to add bags to my list

objects.c:CONTAINER("sack",           "bag", 0, 0, 0, 35,  15,   2, CLOTH, HI_CLOTH),
objects.c:CONTAINER("oilskin sack",   "bag", 0, 0, 0,  5,  15, 100, CLOTH, HI_CLOTH),
objects.c:CONTAINER("bag of holding", "bag", 0, 1, 0, 20,  15, 100, CLOTH, HI_CLOTH),
objects.c:CONTAINER("bag of tricks",  "bag", 0, 1, 1, 20,  15, 100, CLOTH, HI_CLOTH),


OPTIONS=autoletter:h:bag of holding:1
OPTIONS=autoletter:h:oilskin sack:2
OPTIONS=autoletter:h:sack:3
OPTIONS=autoletter:h:bag:4

bag could be bad - bag of tricks.

new options

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none
OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn
OPTIONS=autoletter:h:bag of holding:1
OPTIONS=autoletter:h:oilskin sack:2
OPTIONS=autoletter:h:sack:3
OPTIONS=autoletter:h:bag:4

STATIC_OVL boolean
duplicate_opt_detection(opts, iscompound)
const char *opts;
int iscompound; /* 0 == boolean option, 1 == compound */
{
    int i, *optptr;

    if (!iscompound && iflags.opt_booldup && initial && from_file) {
        for (i = 0; boolopt[i].name; i++) {
            if (match_optname(opts, boolopt[i].name, 3, FALSE)) {
                optptr = iflags.opt_booldup + i;
                *optptr += 1;
                if (*optptr > 1)
                    return TRUE;
                else
                    return FALSE;
            }
        }
    } else if (iscompound && iflags.opt_compdup && initial && from_file) {
        for (i = 0; compopt[i].name; i++) {
            if (match_optname(opts, compopt[i].name, strlen(compopt[i].name),
                              TRUE)) {
                optptr = iflags.opt_compdup + i;
                *optptr += 1;
                if (*optptr > 1)
                    return TRUE;
                else
                    return FALSE;
            }
        }
    }
    return FALSE;
}

somehow this is triggering.

[bobby@localhost ~]$ bobbyhack -D

OPTIONS=autoletter:k:key
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.
 * Line 9: compound option specified multiple times: autoletter:k:key.

11 errors in /home/bobby/.nethackrc.


Hit return to continue:

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none
OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:k:key

I added autoletter here:

static struct Comp_Opt {
    const char *name, *descr;
    int size; /* for frontends and such allocating space --
               * usually allowed size of data in game, but
               * occasionally maximum reasonable size for
               * typing when game maintains information in
               * a different format */
    int optflags;
} compopt[] = {
    { "align", "your starting alignment (lawful, neutral, or chaotic)", 8,
      DISP_IN_GAME },
    { "align_message", "message window alignment", 20, DISP_IN_GAME }, /*WC*/
    { "align_status", "status window alignment", 20, DISP_IN_GAME },   /*WC*/
    { "altkeyhandler", "alternate key handler", 20, SET_IN_GAME },
    { "autoletter", "assign inventory letter", 20, DISP_IN_GAME },
    
I wonder if a different value for optflags would work. Really
don't want to DISP_IN_GAME.

In options.c

/*
 *  NOTE:  If you add (or delete) an option, please update the short
 *  options help (option_help()), the long options help (dat/opthelp),
 *  and the current options setting display function (doset()),
 *  and also the Guidebooks.
 *
 *  The order matters.  If an option is a an initial substring of another
 *  option (e.g. time and timed_delay) the shorter one must come first.
 */

did a kludgy fix to option_help

added to dat/opthelp

I think it is good for now. At least there is some help in the game.

6/15/2020

Next thing is to have it apply the autoletter options
after a restore from a saved game.

start game with no autoletter options

name some weapon My Favorite Weapon
and assign it to some letter other than a.

then save and add this one

OPTIONS=autoletter:a:My Favorite Weapon:1

Should autoassign it back to a.

 Weapons
      a - a +1 long sword (weapon in hand)
      b - a +0 dagger named My Favorite Weapon (alternate weapon; not wielded)
      Armor
      c - a blessed +3 small shield (being worn)
      Comestibles
      d - an uncursed food ration

didn't change.

restore.c maybe?

STATIC_OVL struct obj *
restobjchn(fd, ghostly, frozen)

    invent = restobjchn(fd, FALSE, FALSE);

which is in restgamestate - added at end:

    /* Bobby Durrett - added to apply autoletter options after
       game restore. Pieces of code taken from Preadjust patch */

    struct obj *obj;

    /* loop through the objects in the newly created inventory */

    for (obj = invent; obj; obj = obj->nobj)
        autoletter_adjust(obj);

    /* end autoletter */

Next I need to call autoletter_adjust when and object is named.

cmd.c might be a start

do_name.c:docallcmd()

    case 'i': /* name an individual object in inventory */
        allowall[0] = ALL_CLASSES;
        allowall[1] = '\0';
        obj = getobj(allowall, "name");
        if (obj)
            do_oname(obj);
        break;
        
put here or in do_oname?

done.

***************************************************************************

Now the thing is what if
an object leaves my main inventory
and another object that is also in autoletter for 
the same letter but worse priority.

I.e. 

Drop a bag of holding
Have sack in inventory.

Put a lamp in bag but another lamp
in main inventory.

THere are a lot of ways objects can leave the main inventory.

Is there some main remove from inventory routine?

6/20/2020

Need to poke around with debug statements
try to find what happens when you drop something, etc.

do.c

/* 'd' command: drop one inventory item */
int
dodrop()

freeinv(obj); maybe

invent.c:freeinv(obj)

/* remove an object from the hero's inventory */
void
freeinv(obj)
register struct obj *obj;
{
    extract_nobj(obj, &invent);
    freeinv_core(obj);
    update_inventory();
}

do i do autoletter_adjust before or after update_inventory?

 added:
    addinv_core2(obj);
    carry_obj_effects(obj); /* carrying affects the obj */

    autoletter_adjust(obj); /* Bobby Durrett autoletter */

    update_inventory();
    return obj;
    
This is what I did in addinv. Do the opposite in freeinv(

is not working right with magic lamp and oil lamp:

Tools
 l - an uncursed oil lamp
 m - an uncursed tooled horn
 n - a magic marker (0:77)
 o - a blessed magic lamp

Have to identify after wishing

Maybe this isn't a problem.

Really the issue is to adapt after identifying.

Dropping isn't working either.

Hmm.

My new version

void
freeinv(obj)
register struct obj *obj;
{
    extract_nobj(obj, &invent);
    freeinv_core(obj);

    /* Bobby Durrett apply autoletter options after removing obj */

    struct obj *otmp;

    /* loop through the objects in the remaining inventory */

    for (otmp = invent; otmp; otmp = otmp->nobj)
        autoletter_adjust(otmp);

    /* end autoletter */

    update_inventory();
}

I didn't do bhbuild.sh

Works. Cool.

Now have to fix it so that identifying causes the update.

i.e.

oil lamp first

then magic lamp identified.

magic lamp switches in.

[bobby@localhost src]$ grep fully_identify_obj *.c
invent.c:fully_identify_obj(otmp)

objects might be identified in fully_identify_obj

invent.c

void
fully_identify_obj(otmp)
struct obj *otmp;
{
    makeknown(otmp->otyp);
    if (otmp->oartifact)
        discover_artifact((xchar) otmp->oartifact);
    otmp->known = otmp->dknown = otmp->bknown = otmp->rknown = 1;
    if (Is_container(otmp) || otmp->otyp == STATUE)
        otmp->cknown = otmp->lknown = 1;
    if (otmp->otyp == EGG && otmp->corpsenm != NON_PM)
        learn_egg_type(otmp->corpsenm);
}

Should we stick this at the end?

[bobby@localhost src]$ grep fully_identify_obj *.c | more
invent.c:fully_identify_obj(otmp)
invent.c:    fully_identify_obj(otmp);
invent.c:        /* TODO:  use fully_identify_obj and cornline/menu/whatever here */
quest.c:            fully_identify_obj(otmp);
quest.c:        fully_identify_obj(obj);
[bobby@localhost src]$

only used three places

Works.

I'm putting this a lot of places. Might want to see about using 
binary search if I'm going to call this all the time.

[bobby@localhost binarysearch]$ pwd
/home/bobby/nethack/binarysearch
[

Do some binary search testing here.

[bobby@localhost binarysearch]$ time ./linear

real    0m9.243s
user    0m9.236s
sys     0m0.002s

9 seconds for 10,000,000 lookups with current code.

fixed bug in current lookup. now is


[bobby@localhost binarysearch]$ time ./linear

real    0m5.797s
user    0m5.791s
sys     0m0.003s

[bobby@localhost binarysearch]$ time ./binsearch

real    0m1.388s
user    0m1.386s
sys     0m0.001s

binary search about 4x at 10 million

binary search 100,000,000

[bobby@localhost binarysearch]$ time ./binsearch

real    0m13.817s
user    0m13.809s
sys     0m0.002s

[bobby@localhost binarysearch]$ gcc -o linear linear.c -Wall
[bobby@localhost binarysearch]$ time ./linear

real    0m59.207s
user    0m59.112s
sys     0m0.007s

so, faster but not a ton faster. aboug 4.5x

added binary search.

may want to add some sort of notification out of 
autoletter_adjust of a letter is adjusted.

[bobby@localhost binarysearch]$ time ./binsearch

real    0m13.579s
user    0m13.571s
sys     0m0.002s

Tweaked the logic but didn't really speed up.

still not sure if I can eliminate the last comparision
if mini == maxi

finished updating binary search but my identify change
may have introduced a bug.

If I wish for an unidentified oil lamp and 
magic lamp and then do control-I twice it only
identifies one.

/* make an object actually be identified; no display updating */
void
fully_identify_obj(otmp)
struct obj *otmp;
{
    makeknown(otmp->otyp);
    if (otmp->oartifact)
        discover_artifact((xchar) otmp->oartifact);
    otmp->known = otmp->dknown = otmp->bknown = otmp->rknown = 1;
    if (Is_container(otmp) || otmp->otyp == STATUE)
        otmp->cknown = otmp->lknown = 1;
    if (otmp->otyp == EGG && otmp->corpsenm != NON_PM)
        learn_egg_type(otmp->corpsenm);
/*
    autoletter_adjust(otmp);
*/
}

commented out. 

breaks control-I x2 in wiz mode

I think it is this call in autoletter_swap:

    reorder_invent();
}

probably put autoletter_adjust
after fully_identify_obj
is called one or more times instead
of in fully_identify_obj.

i.e. the ctrl-I x2 place and other
places wait until all the identifying is done
and then adjust the ones identified.

invent.c:fully_identify_obj(otmp)
invent.c:    fully_identify_obj(otmp);
invent.c:        /* TODO:  use fully_identify_obj and cornline/menu/whatever here */
quest.c:            fully_identify_obj(otmp);
quest.c:        fully_identify_obj(obj);
                                        
used here

/* ggetobj callback routine; identify an object and give immediate feedback */
int
identify(otmp)
struct obj *otmp;
{
    fully_identify_obj(otmp);
    prinv((char *) 0, otmp, 0L);
    return 1;
}


/* TODO:  use fully_identify_obj and cornline/menu/whatever here */
for (obj = invent; obj; obj = obj->nobj) {
    if (not_fully_identified(obj)) {
        (void) identify(obj);
        if (unid_cnt == 1)
            break;
    }
}

This is probably the real problem.

Going through the list and autoletter_adjust
modified the list.

Maybe we should find wherever identify or fully_identify_obj
is called and put autoletter_adjust there instead.

Worries me that autoletter_adjust does not work with a loop
like this. Need to verify because we use it when we 
restore a game and start a game also.

See if we are manipulating the list in reorder_invent.

May need my own list outside of the object structure.

/* sort the inventory; used by addinv() and doorganize() */
STATIC_OVL void
reorder_invent()
{
    struct obj *otmp, *prev, *next;
    boolean need_more_sorting;

    do {
        /*
         * We expect at most one item to be out of order, so this
         * isn't nearly as inefficient as it may first appear.
         */
        need_more_sorting = FALSE;
        for (otmp = invent, prev = 0; otmp;) {
            next = otmp->nobj;
            if (next && inv_rank(next) < inv_rank(otmp)) {
                need_more_sorting = TRUE;
                if (prev)
                    prev->nobj = next;
                else
                    invent = next;
                otmp->nobj = next->nobj;
                next->nobj = otmp;
                prev = next;
            } else {
                prev = otmp;
                otmp = next;
            }
        }
    } while (need_more_sorting);
}

This definately tweaks the structure so we cannot call it during a loop through
the same pointers.

        priority = autoletter_array[obj_index].priority;

why in autoletter_adjust do I get priority here and then 
do not use it?

fixed this but need to deal with reorder_invent and the
object list.

autoletter_reorder_invent();

use where needed

[bobby@localhost src]$ grep autoletter_adjust *.c
do_name.c:            autoletter_adjust(obj);
invent.c:    autoletter_adjust(obj); /* Bobby Durrett autoletter */
invent.c:        autoletter_adjust(otmp);
options.c:autoletter_adjust(struct obj *obj)
options.c:autoletter_adjust(struct obj *obj)
restore.c:        autoletter_adjust(obj);

back to fixing identify. Using 

autoletter_adjust(struct obj *obj)

autoletter_reorder_invent()

[bobby@localhost src]$ grep fully_identify_obj *.c
invent.c:fully_identify_obj(otmp)
invent.c:    fully_identify_obj(otmp);
invent.c:        /* TODO:  use fully_identify_obj and cornline/menu/whatever here */
quest.c:            fully_identify_obj(otmp);
quest.c:        fully_identify_obj(obj);


[bobby@localhost src]$ grep identify\( *.c
cmd.c:wiz_identify(VOID_ARGS)
invent.c:identify(otmp)
invent.c:menu_identify(id_limit)
invent.c:                (void) identify(pick_list[i].item.a_obj);
invent.c:                (void) identify(obj);
invent.c:            menu_identify(id_limit);
invent.c:                        (void) identify(otmp);

replaced loops with

autoletter_adjust_all();

 Tools
                                  f - a blessed oil lamp
                                  x - a blessed magic lamp

found a case where switching something out of its old letter
did not result in a lower priority thing filling it.

I saved the game with my standard options - magic lamp 1, oil lamp 2, letter l.

Then I switched magic lamp to x and got the above. 

oil lamp was earlier in the order so I didn't get it in the one pass through the list.

Maybe make multiple passes until all is done switching?

Need to deal with this case and identify.

start with cntrl-I x2

/* ^I command - reveal and optionally identify hero's inventory */
STATIC_PTR int
wiz_identify(VOID_ARGS)
{
    if (wizard) {
        iflags.override_ID = (int) cmd_from_func(wiz_identify);
        /* command remapping might leave #wizidentify as the only way
           to invoke us, in which case cmd_from_func() will yield NUL;
           it won't matter to display_inventory()/display_pickinv()
           if ^I invokes some other command--what matters is that
           display_pickinv() and xname() see override_ID as nonzero */
        if (!iflags.override_ID)
            iflags.override_ID = C('I');
        (void) display_inventory((char *) 0, FALSE);
        iflags.override_ID = 0;
    } else
        pline(unavailcmd, visctrl((int) cmd_from_func(wiz_identify)));
    return 0;
}

maybe here

                if (otmp == &wizid_fakeobj) {
                    identify_pack(0, FALSE);
                } else {
                    if (not_fully_identified(otmp))
                        (void) identify(otmp);

in identify_pack

    }
    update_inventory();
}

I think put there.

Seems to work. 

6/21/2020 5:06 PM MST

Two key things two work on:

1 - add some sort of output letting us know a letter was switched
    (identify looks odd because it identifies it with the old letter then it
    silently switches)

2 - adjust remaining letters after one letter successfully switches
    (should there be a limit to the depth of the recursion?)

Also, I need a written test case list instead of having it in my head.

6/26/2020

identify bug:

wish for an oil lamp, then a magic lamp, 
and then identify both with control-I x2.

g - a blessed magic lamp.  l - a blessed oil lamp.

didn't seem to get magic lamp.

 Tools
                         g - a blessed oil lamp
                         l - a blessed magic lamp

but they are swapped in the inventory.

I guess this bug is really about what feedback we should get.

If I leave these in teh inventory and save
then change option to make magic lamp x you get

 Tools
                         g - a blessed oil lamp
                         x - a blessed magic lamp

So, here is a real bug. oil lamp should switch to l.

void
autoletter_adjust_all()
{
    struct obj *obj;
    int i;

    /* loop through the objects in the newly created inventory twice */

    for (i = 0; i < 2 ; i++)
        for (obj = invent; obj; obj = obj->nobj)
            autoletter_adjust(obj);
}

changed to make two passes and it fixed the issue:

 Tools
  l - a cursed oil lamp
  x - a blessed magic lamp
  
maybe two passes through the list is all it needs?

still need to fix the way it appears - output.

added autoletter_notify and it works pretty well.

6/27/2020 6:18 PM

Possible speedup idea

Add a new 52 element array called autoletter_inventory.

Elements of the array have these fields

object pointer

desired letter

priority

autoletter_changed - true if changed based on autoletter option

Elements 0-25 represent lower case letters a-z
26-51 represent upper case A-Z.

The main reason for this is that in autoletter_swap 
we scan the full inventory list looking for an existing object
with the desired letter.

In autoletter_adjust_all we scan the full inventory
list twice calling autoletter_adjust for each object
which calls autoletter_swap.

So, autoletter_adjust_all is O(n^2) where n is size
of the inventory. Of course n is no more than 52
so not sure asymptotics matter.

Idea is to rewrite autoletter_adjust_all and its
underlying routines using autoletter_inventory to make
autoletter_adjust_all O(n).

Also, eliminate autoletter_reorder_invent and its call
to the inefficient reorder_invent by including the
relinking of the inventory linked list in 
autoletter_adjust_all.

General algorithm *******************************************************************************

set autoletter_changed to false for entire array and put 0 or NULL in all 
entries.

Loop through the inventory looking at each a-zA-Z lettered object.

    lookup current object in autoletter_array
    
    if not in array then
    
        if the autoletter_inventory entry for that object's letter is empty then
        
            put that object (pointer) in the entry. object letter is unchanged.
       
        else 
            if the object in the slot has a priority and desired letter - meaning it was set 
            by a autoletter object then
            
                put the current object in the nearest empty letter entry and change the object's letter
                to the letter for that slot
                
            else if the object in the slot has zeros for priority and letter then it was just put there
            by some autoletter switch so then
            
                move the object in the slot to the nearest empty letter and change its letter to match
                the new slot
                
                put the current object in the now empty slot and leave its letter unchanged.
            
    else if object is in autoletter_array then
    
        if autoletter_inventory entry for the desired letter is empty then
        
            put the object in the slot for the desired letter
            
            if the object's letter does not match the desired letter then
                 
                 change the object's letter to that letter
                 
                 set autoletter_changed to True
                             
        else if the autoletter_inventory has an existing entry then
        
            if the existing object has no priority (not in autoletter_array) then
                
                move the existing object in the autoletter_inventory slot for the desired letter to
                the closest empty slot and set the object's letter to that slot's letter
                
                put the current object in the in the entry and change the object's letter to the
                desired letter
                
                set autoletter_changed to True if that object's letter was not already the desired letter
                
            else if current object has higher priority (lower number) than existing object then
            
                move the existing object in the autoletter_inventory slot for the desired letter to
                the closest empty slot and set the object's letter to that slot's letter
                
                set the moved object's autoletter_changed to false
                
                put the current object in the in the entry and change the object's letter to the
                desired letter
                
                set autoletter_changed to True if that object's letter was not already the desired letter
                
            else if the current object has a lower priority than the existing object then.
            
                put the object in the nearest empty letter entry and change the object's letter
                to the letter for that slot
                
                
After the first loop is done loop through the autoletter_inventory array skipping any empty entry and 
relinking the entire inventory linked list based on the order they appear in the array.

Output a notice for any entry with autoletter_changed true.

END OF ALGORITHM ********************************************************************************************

Would like to do performance testing outside nethack like I did for the binary search lookup.

may have to fake some of the types like the object list, etc.

The new algorithm should scan through the inventory list twice so that makes it O(n).

6/30/2020

[bobby@localhost inventoryarray]$ pwd
/home/bobby/inventoryarray
[bobby@localhost inventoryarray]$ ls -al
total 36
drwxrwxr-x.  2 bobby bobby    46 Jun 30 19:59 .
drwx------. 15 bobby bobby  4096 Jun 30 19:16 ..
-rwxrwxr-x.  1 bobby bobby 13760 Jun 30 19:59 linkedlists
-rw-rw-r--.  1 bobby bobby 15854 Jun 30 19:59 linkedlists.c
[bobby@localhost inventoryarray]$

started work on performance test outside nethack.

/* test my current non-array version of
autoletter_adjust_all() and get a performance
baseline */

int
main()
{
    struct obj myobjs[3];

    invent = myobjs;

    myobjs[0].nobj = myobjs+1;
    myobjs[0].invlet = 'a';
    myobjs[0].nametype = "short sword";

    myobjs[1].nobj = myobjs+2;
    myobjs[1].invlet = 'b';
    myobjs[1].nametype = "lamp";

    myobjs[2].nobj = 0;
    myobjs[2].invlet = 'c';
    myobjs[2].nametype = "bag";


    insert_autoletter('h',"bag", 1);
    insert_autoletter('l',"lamp", 1);

    autoletter_adjust_all();

    autoletter_reorder_invent();

    struct obj *obj;

    for (obj = invent; obj; obj = obj->nobj) {
        printf("invlet = %c\n",obj->invlet);
        printf("nametype = %s\n",obj->nametype);
    }

    return 0;
}

[bobby@localhost inventoryarray]$ ./linkedlists
Adjusting lamp to letter l.
Adjusting bag to letter h.
invlet = a
nametype = short sword
invlet = h
nametype = bag
invlet = l
nametype = lamp

need to get rid of the "Adjusting ..." output
and setup a larger object list and 
run autoletter_adjust_all bunch of times.

Then rewrite it all with inventory array
and see if it is faster and works.

setup my test to do my 36 item inventory from
alt org and to use my real options

ran 1000000 loops:

[bobby@localhost inventoryarray]$ gcc -o linkedlists linkedlists.c -Wall
[bobby@localhost inventoryarray]$ time ./linkedlists

real    0m17.946s
user    0m17.829s
sys     0m0.015s

about 18 microseconds per loop

will using an inventory array be faster, cleaner?

changed blindfold to X

[bobby@localhost inventoryarray]$ time ./linkedlists

real    0m17.501s
user    0m17.493s
sys     0m0.000s


rewrote autoletter_adjust_all.

still need to write

/*

void
autoletter_relink()

Loop through the autoletter_inventory array skipping any empty entry and
relink the entire inventory linked list based on the order they appear in the array.

Skip gold entry if there is one.

Output a notice for any entry with autoletter_changed true. */

void
autoletter_relink()
{
}

need to go over the algorithm and make sure the if's and brackets all match correctly.

7/3/2020

put this all together quickly. Need to check error handling and
clean up the comments.

Also need to make sure this will work correctly with gold $ in the
inventory list.

stick this somewhere:

for (obj = invent; obj; obj = obj->nobj)
    write_debug_file_obj(obj);


stuck in restore.c

    /* Bobby Durrett - added to apply autoletter options after
       game restore. */
       
    struct obj *obj;

    for (obj = invent; obj; obj = obj->nobj)
        write_debug_file_obj(obj);

    autoletter_adjust_all();

    autoletter_reorder_invent();

    return TRUE;
}

Inventory letter = $
No object name
In inventory
object type number = 415
Object class name = gold piece
Object class description = (null)
simple_typename(obj->otyp) = coin
cxname_singular(obj) = gold piece
autoletter_name_type(obj) = gold piece
Inventory letter = a
No object name
In inventory
object type number = 57
Object class name = mace
Object class description = (null)
simple_typename(obj->otyp) = mace
cxname_singular(obj) = mace
autoletter_name_type(obj) = mace

Like I thought first entry is $

finished writing relink code.

Not really working.

[bobby@localhost inventoryarray]$ ./array
invlet = a
nametype = Stormbringer
invlet = b
nametype = blindfold
invlet = c
nametype = dagger
invlet = d
nametype = ring of teleport control

only gets the first 4 elements.

So, need to debug. 

At least it is all written down.

first perf run

[bobby@localhost inventoryarray]$ time ./array

real    0m8.587s
user    0m8.582s
sys     0m0.001s

8.5 microseconds

want to fix next empty.

old version

/*

int
find_close_empty(int inv_index)

find the closest empty autoletter_inventory entry
relative to the inv_index location

need to rewrite this to make a single pass from the beginning
no entry is ever emptied so just keep track of the last empty
location and move down to the next one.

change to find_empty instead off find_close_empty

*/

int
find_close_empty(int inv_index)
{
    int down;
    int up;
    int increment;

    for (increment = 1 ; increment < (NUM_LETTERS / 2) ; increment++) {
        down = inv_index - increment;
        up = inv_index + increment;

        if (down >= 0)
            if (autoletter_inventory[down].obj == 0)
                return down;

        if (up < NUM_LETTERS)
            if (autoletter_inventory[up].obj == 0)
                return up;
    }

    /* should never get here */

    return 0;
}

[bobby@localhost inventoryarray]$ time ./array

real    0m8.556s
user    0m8.551s
sys     0m0.000s

not a ton faster with the new find_empty.

[bobby@localhost bobbyhack]$ git log
commit 2b38d3cbb360b7bd634930b723e237ec49323716
Author: bobbydurrett <bobby@bobbydurrettdba.com>
Date:   Fri Jul 3 07:41:18 2020 -0700

    updated status

Last commit before this mega change.

removing

autoletter_adjust
autoletter_swap
autoletter_should_swap
autoletter_reorder_invent

replace these typical uses:

invent.c:    autoletter_adjust_all();
invent.c:    autoletter_reorder_invent();

invent.c:    autoletter_adjust(obj);
invent.c:    autoletter_reorder_invent();

with

autoletter_adjust_all();

pretty much works. Needs more testing to verify all the cases.

failed:

wished for lamp

identified as oil lamp

wished for magic lamp (unidentified)

                               Tools
                               e - an uncursed oil lamp
                               l - a lamp
 
switched
 
      Adjusting lamp to letter l.  l - a lamp.
      For what do you wish? magic lamp
      l - an uncursed oil lamp.
      Adjusting lamp to letter l.  l - a lamp.
      For what do you wish? lamp

I think this is due to the order that these are in the list

may need a tweak to autoletter_adjust_all to keep the previous
letter there?

added code for == priority and notifications

some weird freaking stuff with save files and 
oil and magic lamp.

start in this situation:

e - an uncursed oil lamp
l - a cursed magic lamp

save and restore game - my normal options

this feedback:

Restoring save file...  Adjusting magic lamp to letter l.--More--

still

e - an uncursed oil lamp
l - a cursed magic lamp

#adjust e to m - letter after l

now is

l - a cursed magic lamp
m - an uncursed oil lamp

save and restore game

no message and back to this:

e - an uncursed oil lamp
l - a cursed magic lamp

Hmm.

Seems to be a lot of work needed testing.

Yikes.

Need to move the autoletter_adjust_all code into
functions so it is not so large and hard to follow.

took out debugging

updated comments

seems to be working pretty well. Need to look 
for other bugs.

7/4/2020

There is some bug where inventory gets lost.

Was trying to fill inventory with lamps and suddenly only one was left!

Test:

start new game and drop all inventory.

Then start wishing for lamp one after another.

1

l - a lamp

2

a - a lamp
l - a lamp

3

a - a lamp
b - a lamp
l - a lamp

4

b - a lamp
c - a lamp
d - a lamp
l - a lamp

Why didn't lamp a stay in place?

5

d - a lamp
e - a lamp
f - a lamp
g - a lamp
l - a lamp

Have we lost the first three slots?

6

g - a lamp
h - a lamp
i - a lamp
j - a lamp
k - a lamp
l - a lamp

7

k - a lamp
l - a lamp
m - a lamp
n - a lamp
o - a lamp
p - a lamp
q - a lamp

8

l - a lamp
q - a lamp
r - a lamp
s - a lamp
t - a lamp
u - a lamp
v - a lamp
w - a lamp

9

l - a lamp
w - a lamp
x - a lamp
y - a lamp
z - a lamp
A - a lamp
B - a lamp
C - a lamp
D - a lamp

10

l - a lamp
D - a lamp
E - a lamp
F - a lamp
G - a lamp
H - a lamp
I - a lamp
J - a lamp
K - a lamp
L - a lamp

11

l - a lamp
L - a lamp
M - a lamp
N - a lamp
O - a lamp
P - a lamp
Q - a lamp
R - a lamp
S - a lamp
T - a lamp
U - a lamp

12

l - a lamp
U - a lamp
V - a lamp
W - a lamp
X - a lamp
Y - a lamp
Z - a lamp

13

Adjusting lamp to letter l.  l - a lamp.

l - a lamp

I think this is just a bug in the empty thing.

Have to reset the start point. Funny.

First 52 wishes worked well.

But on the 53rd I get this:

# - a lamp.

But it is not in the list.

same with wand of wishing

This seems to be a bug I introduced.

In 3.6.6 it gives this message:

Oops!  The oil lamp drops to the floor!

So, need to fix this so wishing for the 53rd lamp
gives the Oops! message.

bobbyhack branch without autoletter merged in yet
gives the same Oops! message so this is a bug
we introduced with autoletter

[bobby@localhost src]$ grep Oops! *.c | grep "to the floor"
mkobj.c:                                          : "Oops!  %s to the floor!",
zap.c:                            : "Oops!  %s to the floor!");

mkobj.c

            obj = hold_another_object(obj,
                                      u.uswallow
                                        ? "Oops!  %s out of your reach!"
                                        : (Is_airlevel(&u.uz)
                                           || Is_waterlevel(&u.uz)
                                           || levl[u.ux][u.uy].typ < IRONBARS
                                           || levl[u.ux][u.uy].typ >= ICE)
                                          ? "Oops!  %s away from you!"
                                          : "Oops!  %s to the floor!",
                                      The(aobjnam(obj, "slip")), (char *) 0);

zap.c in makewish()

    /* KMH, conduct */
    u.uconduct.wishes++;

    if (otmp != &zeroobj) {
        const char
            *verb = ((Is_airlevel(&u.uz) || u.uinwater) ? "slip" : "drop"),
            *oops_msg = (u.uswallow
                         ? "Oops!  %s out of your reach!"
                         : (Is_airlevel(&u.uz) || Is_waterlevel(&u.uz)
                            || levl[u.ux][u.uy].typ < IRONBARS
                            || levl[u.ux][u.uy].typ >= ICE)
                            ? "Oops!  %s away from you!"
                            : "Oops!  %s to the floor!");

        /* The(aobjnam()) is safe since otmp is unidentified -dlc */
        (void) hold_another_object(otmp, oops_msg,
                                   The(aobjnam(otmp, verb)),
                                   (const char *) 0);
        u.ublesscnt += rn1(100, 50); /* the gods take notice */

looks like hold_another_object does the actual check and pline

invent.c

        if (inv_cnt(FALSE) > 52 || ((obj->otyp != LOADSTONE || !obj->cursed)
                                    && near_capacity() > prev_encumbr)) {
            /* undo any merge which took place */
            if (obj->quan > oquan)
                obj = splitobj(obj, oquan);
            goto drop_it;
            
hack.c

int
inv_cnt(incl_gold)
boolean incl_gold;
{
    register struct obj *otmp = invent;
    register int ct = 0;

    while (otmp) {
        if (incl_gold || otmp->invlet != GOLD_SYM)
            ct++;
        otmp = otmp->nobj;
    }
    return ct;
}

This all fails because this code depends on inventory temporarily going over
52 and then being removed.

Save # object in main loop and add back in relink.

static struct obj *pound_obj; 

fixed.

just saved and added back # letter

add inventory_count for sanity check.

Inventory count mismatch in autoletter_relink

got this will inventory full of lamps and gold pieces
then wish for another lamp

gold is being lost somehow

maybe # is at front

gold_obj

fixed.

OPTIONS=autoletter:b:blindfold
OPTIONS=autoletter:l:magic lamp:1
OPTIONS=autoletter:l:lamp:2
OPTIONS=autoletter:l:oil lamp:2
OPTIONS=autoletter:l:brass lantern:2
OPTIONS=autoletter:k:key
OPTIONS=autoletter:k:skeleton key
OPTIONS=autoletter:m:mirror
OPTIONS=autoletter:m:looking glass
OPTIONS=autoletter:w:magic whistle:1
OPTIONS=autoletter:w:whistle:2
OPTIONS=autoletter:p:pick-axe
OPTIONS=autoletter:u:unicorn horn
OPTIONS=autoletter:h:bag of holding:1
OPTIONS=autoletter:h:oilskin sack:2
OPTIONS=autoletter:h:sack:3
OPTIONS=autoletter:h:bag:4

adjusting and dropping and restoring
does not give a message.

gets adjusted as you drop them.

got an infinite loop. Trying

OPTIONS=autoletter:S:scroll of magic mapping

two different groups of magic mapping scrolls
neither of which are set to S

hangs here

Restoring save file...
NetHack, Copyright 1985-2020
         By Stichting Mathematisch Centrum and M. Stephenson.
         Version 3.6.6-0 Unix post-release, built Jul  4 10:54:31 2020.
         See license for details.

Yikes!

/*    if (bytes_formatted > 0)
        pline(buffer); */
        
blowing up in pline in autoletter_notify

/*    if (bytes_formatted > 0)
        pline(buffer); */

commented out and it works.

Need to think about how to fix.

bug:

cp .nethackrc.fullwithmyautoletter .nethackrc

bobbyhack -D

Setup like this as only inventory:

h - 2 blessed scrolls of magic mapping
j - an uncursed scroll of magic mapping

Save game

cp .nethackrcloop .nethackrc

in debug window

./cleartail.sh

start game

bobbyhack -D

hangs here:

Restoring save file...
NetHack, Copyright 1985-2020
         By Stichting Mathematisch Centrum and M. Stephenson.
         Version 3.6.6-0 Unix post-release, built Jul  4 20:24:01 2020.
         See license for details.


debug ends here:

location 1
curr_entry = 43
location 1
curr_entry = 44
location 1
location 2
location 3
location 4
location 5
location 6
Inventory letter = S
No object name
In inventory
object type number = 313
Object class name = magic mapping
Object class description = ELAM EBOW
simple_typename(obj->otyp) = scroll of magic mapping
In xname_flags
End of xname_flags
cxname_singular(obj) = scroll of magic mapping
In autoletter_name_type
In xname_flags
End of xname_flags
autoletter_name_type(obj) = scroll of magic mapping
In autoletter_notify
letter = S
In autoletter_name_type
In xname_flags
End of xname_flags
bytes_formatted = 46
buffer = Adjusting scroll of magic mapping to letter S.
Middle autoletter_notify

Kill game

[bobby@localhost src]$ ps -ef | grep bobbyhack
bobby     8935  1485 99 20:30 pts/0    00:00:47 /home/bobby/nethack/games/lib/bobbyhackdir/bobbyhack -D
bobby     8938  1611  0 20:31 pts/1    00:00:00 grep bobbyhack
[bobby@localhost src]$ kill -9 8935

7/5/2020

Took out debug statements to get rid of the clutter. 

Trying with no other autoletter options

Start game with no options.

After setting up add the one for magic mapping to S

Still hangs

[bobby@localhost ~]$ diff .nethackrc .nethackrcsimplefails
7a8
> OPTIONS=autoletter:S:scroll of magic mapping

just the one option.

Try with only 2 uncursed scrolls

g - 2 uncursed scrolls of magic mapping

Restoring save file...  Adjusting scroll of magic mapping to letter S.

works

Try with 1 blessed scroll and 1 uncursed scroll

Fails.

so it has nothing to do with stacking as far as I can tell.

Try with lower case letter s instead of S

OPTIONS=autoletter:s:scroll of magic mapping

hangs.

So, has nothing to do with upper case.

Next thing is try two non-scrolls like
uncursed and blessed oil lamp.
not stackable.

e - a blessed oil lamp
f - an uncursed oil lamp

save game

OPTIONS=autoletter:l:oil lamp

hangs

seems like it is my equal priority section.

Try it with

OPTIONS=autoletter:l:oil lamp:2

a - a blessed oil lamp
m - an uncursed oil lamp

hangs.

does not happen when I drop a higher priority object and it has to pick on.

Happens on the restore only so far.

void
autoletter_adjust_all(boolean notify)
{
    /* set global to turn messages off or on */

    autoletter_notify = notify;

just turn pline off on restores


had to change the global to

autoletter_pline

Fixed bug.

want to make sure none of these default

    struct obj *obj;                                    /* pointer to inventory object */
    char desired_letter;                                /* letter that autoletter wants to assign to obj */
    int priority;                                       /* priority if there are multiple entries same letter 1 highest */
    boolean autoletter_changed;                         /* true if object letter changed based on autoletter option */



        autoletter_inventory[empty_index].obj = obj;
        autoletter_inventory[empty_index].desired_letter = '\0';
        autoletter_inventory[empty_index].priority = 0;
        autoletter_inventory[empty_index].autoletter_changed = FALSE;

added ifs for autoletter_pline everywhere I used pline

made all the autoletter_inventory settings explicit for all the conditions

