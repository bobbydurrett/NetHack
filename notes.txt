bobbyhack notes

https://www.bobbydurrettdba.com/nethackgame/

nethack@bobbydurrettdba.com

5/23/19

bobbyhack in its current state is some point in the 3.6.2 beta github stream of commits with four of my 
branches merged into it. They are:

tigerfix
silversword
crazyants
building

I have been doing some brainstorming and I want to move forward with bobbyhack as the base branch for 
my own version of nethack. 

At this point the four branches I created are not part of any cohesive plan or adventure but I hope over
time to mold bobbyhack into my own game with some interesting parts to it. Whether I have time to do so
does not matter. Here are some key ideas:

If I want to catch up with newer code from the Dev team create a new branch off of bobbyhack and work out
the merge issues with the new code. Then merge that branch back in.

If I want to work on some new idea make a branch off of bobbyhack and not the main devteam branch (3.6 at this time).
That way I will always be making changes that are compatible with my game. If I ever write something useful I can 
always go back and retrofit the change to be a patch on top of the latest version or the ongoing git stream.

Keep this file in the commits as my notes of what I am doing. If I merge a branch back into bobbyhack it will have 
an updated version of this file. I have taken a similar approach with the repositories that I used for my
Rosetta Code contributions and I like having a log of what I'm doing in a text file on GitHub.

I debated starting bobbyhack over from scratch from the recently released 3.6.2 release but decided to move forward
from bobbyhack as it is today and merge in devteam changes as desired. Also, I thought about not using the four
existing branches because they are not designed to fit into any story or adventure. But, I can always back them out 
later if I decide to not use them. I put time into testing them so I want to keep them in my code.

Last time I rebased bobbyhack and then added in the four branches. I don't really care about rebasing to clean
up the way the commits look. I want to keep my existing bobbyhack commits out there and move forward. I deleted
my rebase.sh script so I would not accidentally redo the rebasing of bobbyhack.

I thought about coming up with some new clever name like Terebynthia or something but I'm already attached to 
bobbyhack so that is another reason to move forward.

I can follow the devteam's latest code in nethack-git repo while keeping bobbyhack in a separate repo.

Probably my first task after creating this notes.txt file will be to try to merge in the 3.6.2 release changes.

5/24/19

Working on merging in the 3.6.2 release changes.

Merged in 3.6.2 updating monst.c to use 3.6.2 queen bee last line.

Deleted Makefiles. Need to redeploy and manually edit for GAME=bobbyhack
and flex and bison.

Looks like 3.6.2 added another field in the MON macro in monst.c.

Picked a number for crazy ants like a giant ant.

Seems to work.

4/28/2020

Working on adding in the 3.6.6 changes.

[bobby@localhost bobbyhack]$ git checkout bobbyhack
Switched to branch 'bobbyhack'
[bobby@localhost bobbyhack]$ view notes.txt
[bobby@localhost bobbyhack]$ pwd
/home/bobby/nethack/bobbyhack
[bobby@localhost bobbyhack]$ git branch add366
[bobby@localhost bobbyhack]$ git checkout add366
Switched to branch 'add366'

bunch of stuff to get this working

cd /home/bobby/nethack/nethack-git
git fetch upstream
git checkout NetHack-3.6
git merge --ff-only upstream/NetHack-3.6
git push

git push --set-upstream origin NetHack-3.6

git branch --set-upstream-to=remotes/upstream/NetHack-3.6

did not seem to be any conflicts. Good be pretty easy.

[bobby@localhost nethack]$ bhbuild.sh

does tags and all

current branch

everything looks good. Not so bad.

5/2/2020

created autoletter branch

5/3/2020

Created a simple function to write a string to a debugging file.

File is /home/bobby/nethack/debugfile.log

Function is write_debug_file(char *string) in files.c.

Can use it anywhere.

Could create formatted front ends to write_debug_file like

write_debug_file_int(char *format,int data)

int snprintf(formatted_string, 80, format, data);

If formats to more than 80 characters abort.

Could do one for each type we might need. Not sure yet what those would be.

debug functions are up to these now: (in extern.h)

/* Bobby Durrett debug file functions */

E void write_debug_file(char *string);
E void write_debug_file_datetime();
E void write_debug_file_str(char *format,char *data);
E void write_debug_file_int(char *format,int data);

could clone write_debug_file_str or write_debug_file_int for other types
just passes one parameter into format string. should be ok for debugging.

possible other types for debug:

    unsigned oeaten;        /* nutrition left in food, if partly eaten */
    long age;               /* creation date */
    short otyp; /* object class number */
    schar spe; /* quality of weapon, weptool, armor or ring (+ or -);
    xchar ox, oy;
    Bitfield(cursed, 1);


typedef signed char schar;

https://vim.fandom.com/wiki/Browsing_programs_with_tags

typedef schar xchar;

looks like we need short, long, char.

unsigned can work with int

https://en.wikipedia.org/wiki/C_data_types

Looks like long would be helpful. Others can adjust.

added

E void write_debug_file_long(char *format,long data);

5/4/2020

Cleaned up the debug file stuff a little bit.

Put test code in /home/bobby/debugfile

5/9/2020

Poking around.

boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;

in options.c

I think it is called for each option in .nethackrc

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none


boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;
{
    write_debug_file_str("In parseoptions opts = %s\n",opts);


[bobby@localhost debugfile]$ cat /dev/null > debugfile.log;tail -f debugfile.log
In parseoptions opts = noshowexp,showscore,time,color,!autopickup
In parseoptions opts = showscore,time,color,!autopickup
In parseoptions opts = time,color,!autopickup
In parseoptions opts = color,!autopickup
In parseoptions opts = !autopickup
In parseoptions opts = autodig,ibmgraphics,autoquiver,noautoopen
In parseoptions opts = ibmgraphics,autoquiver,noautoopen
In parseoptions opts = autoquiver,noautoopen
In parseoptions opts = noautoopen
In parseoptions opts = number_pad:0,msg_window:reversed
In parseoptions opts = msg_window:reversed
In parseoptions opts = hilite_pet,hilite_pile,pickup_burden:unencumbered
In parseoptions opts = hilite_pile,pickup_burden:unencumbered
In parseoptions opts = pickup_burden:unencumbered
In parseoptions opts = disclose:yi ya yv yg yc yo
In parseoptions opts = boulder:`
In parseoptions opts = sortloot:none

Looks like it just processes the first option passed to it.

    if ((op = index(opts, ',')) != 0) {
        *op++ = 0;
        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

I guess this sticks a 0 where the first comma is so the rest of the function
can use opts as if it didn't have a comma.

Then it calls itself with op pointing to the string after the comma.

[bobby@localhost src]$ grep parseoptions *.c
files.c:        ++bufp; /* skip '='; parseoptions() handles spaces */
files.c:        if (!parseoptions(bufp, TRUE, TRUE))
options.c:             * parseoptions() will check each individually
options.c:            (void) parseoptions(opts, TRUE, FALSE);
options.c:/* paranoia[] - used by parseoptions() and special_handling() */
options.c:parseoptions(opts, tinitial, tfrom_file)
options.c:        if (!parseoptions(op, initial, from_file))
options.c:         * or prompt for new values. In most cases, call parseoptions()
options.c:                (void) parseoptions(buf, setinitial, fromfile);
options.c:                    (void) parseoptions(buf, setinitial, fromfile);
options.c:        /* parseoptions will prompt for the list of types */
options.c:        (void) parseoptions(strcpy(buf, "pickup_types"),
vision.c: *      + After an option has changed that affects vision [parseoptions()]

Mostly return value is ignored except in files.c.

        if (!parseoptions(bufp, TRUE, TRUE))
            retval = FALSE;

this uses returned value in files.c
in function 

boolean
parse_config_line(origbuf)
char *origbuf;

But what the heck is parse_config_line doing?

boolean
parse_config_line(origbuf)
char *origbuf;
{
    write_debug_file_str("In parse_config_line origbuf = %s\n",origbuf);


clear; cat /dev/null > debugfile.log;tail -f debugfile.log

In parse_config_line origbuf = WIZARDS=bobby
In parse_config_line origbuf = EXPLORERS=*
In parse_config_line origbuf = MAXPLAYERS=10
In parse_config_line origbuf = GDBPATH=/usr/bin/gdb
In parse_config_line origbuf = GREPPATH=/bin/grep
In parse_config_line origbuf = PANICTRACE_GDB=1
In parse_config_line origbuf = PANICTRACE_LIBC=2
More than MAX_LINE_SIZE character string in write_debug_file_str
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=number_pad:0,msg_window:reversed
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=disclose:yi ya yv yg yc yo
In parse_config_line origbuf = OPTIONS=boulder:`
In parse_config_line origbuf = OPTIONS=sortloot:none

I guess these are the uncommented lines in sysconf as well as the .nethackrc

[bobby@localhost nethack]$ grep = /home/bobby/nethack/games/lib/bobbyhackdir/sysconf | grep -v \#
WIZARDS=bobby
EXPLORERS=*
MAXPLAYERS=10
GDBPATH=/usr/bin/gdb
GREPPATH=/bin/grep
PANICTRACE_GDB=1
PANICTRACE_LIBC=2

I'm thinking autoletter should be an option since it is related to game
play and not configuration of the system relative to Linux.

