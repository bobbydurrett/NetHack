bobbyhack notes

https://www.bobbydurrettdba.com/nethackgame/

nethack@bobbydurrettdba.com

5/23/19

bobbyhack in its current state is some point in the 3.6.2 beta github stream of commits with four of my 
branches merged into it. They are:

tigerfix
silversword
crazyants
building

I have been doing some brainstorming and I want to move forward with bobbyhack as the base branch for 
my own version of nethack. 

At this point the four branches I created are not part of any cohesive plan or adventure but I hope over
time to mold bobbyhack into my own game with some interesting parts to it. Whether I have time to do so
does not matter. Here are some key ideas:

If I want to catch up with newer code from the Dev team create a new branch off of bobbyhack and work out
the merge issues with the new code. Then merge that branch back in.

If I want to work on some new idea make a branch off of bobbyhack and not the main devteam branch (3.6 at this time).
That way I will always be making changes that are compatible with my game. If I ever write something useful I can 
always go back and retrofit the change to be a patch on top of the latest version or the ongoing git stream.

Keep this file in the commits as my notes of what I am doing. If I merge a branch back into bobbyhack it will have 
an updated version of this file. I have taken a similar approach with the repositories that I used for my
Rosetta Code contributions and I like having a log of what I'm doing in a text file on GitHub.

I debated starting bobbyhack over from scratch from the recently released 3.6.2 release but decided to move forward
from bobbyhack as it is today and merge in devteam changes as desired. Also, I thought about not using the four
existing branches because they are not designed to fit into any story or adventure. But, I can always back them out 
later if I decide to not use them. I put time into testing them so I want to keep them in my code.

Last time I rebased bobbyhack and then added in the four branches. I don't really care about rebasing to clean
up the way the commits look. I want to keep my existing bobbyhack commits out there and move forward. I deleted
my rebase.sh script so I would not accidentally redo the rebasing of bobbyhack.

I thought about coming up with some new clever name like Terebynthia or something but I'm already attached to 
bobbyhack so that is another reason to move forward.

I can follow the devteam's latest code in nethack-git repo while keeping bobbyhack in a separate repo.

Probably my first task after creating this notes.txt file will be to try to merge in the 3.6.2 release changes.

5/24/19

Working on merging in the 3.6.2 release changes.

Merged in 3.6.2 updating monst.c to use 3.6.2 queen bee last line.

Deleted Makefiles. Need to redeploy and manually edit for GAME=bobbyhack
and flex and bison.

Looks like 3.6.2 added another field in the MON macro in monst.c.

Picked a number for crazy ants like a giant ant.

Seems to work.

4/28/2020

Working on adding in the 3.6.6 changes.

[bobby@localhost bobbyhack]$ git checkout bobbyhack
Switched to branch 'bobbyhack'
[bobby@localhost bobbyhack]$ view notes.txt
[bobby@localhost bobbyhack]$ pwd
/home/bobby/nethack/bobbyhack
[bobby@localhost bobbyhack]$ git branch add366
[bobby@localhost bobbyhack]$ git checkout add366
Switched to branch 'add366'

bunch of stuff to get this working

cd /home/bobby/nethack/nethack-git
git fetch upstream
git checkout NetHack-3.6
git merge --ff-only upstream/NetHack-3.6
git push

git push --set-upstream origin NetHack-3.6

git branch --set-upstream-to=remotes/upstream/NetHack-3.6

did not seem to be any conflicts. Good be pretty easy.

[bobby@localhost nethack]$ bhbuild.sh

does tags and all

current branch

everything looks good. Not so bad.

5/2/2020

created autoletter branch

5/3/2020

Created a simple function to write a string to a debugging file.

File is /home/bobby/nethack/debugfile.log

Function is write_debug_file(char *string) in files.c.

Can use it anywhere.

Could create formatted front ends to write_debug_file like

write_debug_file_int(char *format,int data)

int snprintf(formatted_string, 80, format, data);

If formats to more than 80 characters abort.

Could do one for each type we might need. Not sure yet what those would be.

debug functions are up to these now: (in extern.h)

/* Bobby Durrett debug file functions */

E void write_debug_file(char *string);
E void write_debug_file_datetime();
E void write_debug_file_str(char *format,char *data);
E void write_debug_file_int(char *format,int data);

could clone write_debug_file_str or write_debug_file_int for other types
just passes one parameter into format string. should be ok for debugging.

possible other types for debug:

    unsigned oeaten;        /* nutrition left in food, if partly eaten */
    long age;               /* creation date */
    short otyp; /* object class number */
    schar spe; /* quality of weapon, weptool, armor or ring (+ or -);
    xchar ox, oy;
    Bitfield(cursed, 1);


typedef signed char schar;

https://vim.fandom.com/wiki/Browsing_programs_with_tags

typedef schar xchar;

looks like we need short, long, char.

unsigned can work with int

https://en.wikipedia.org/wiki/C_data_types

Looks like long would be helpful. Others can adjust.

added

E void write_debug_file_long(char *format,long data);

5/4/2020

Cleaned up the debug file stuff a little bit.

Put test code in /home/bobby/debugfile

5/9/2020

Poking around.

boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;

in options.c

I think it is called for each option in .nethackrc

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=noshowexp,showscore,time,color,!autopickup
OPTIONS=autodig,ibmgraphics,autoquiver,noautoopen
OPTIONS=number_pad:0,msg_window:reversed
OPTIONS=hilite_pet,hilite_pile,pickup_burden:unencumbered
OPTIONS=disclose:yi ya yv yg yc yo
OPTIONS=boulder:`
OPTIONS=sortloot:none


boolean
parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;
{
    write_debug_file_str("In parseoptions opts = %s\n",opts);


[bobby@localhost debugfile]$ cat /dev/null > debugfile.log;tail -f debugfile.log
In parseoptions opts = noshowexp,showscore,time,color,!autopickup
In parseoptions opts = showscore,time,color,!autopickup
In parseoptions opts = time,color,!autopickup
In parseoptions opts = color,!autopickup
In parseoptions opts = !autopickup
In parseoptions opts = autodig,ibmgraphics,autoquiver,noautoopen
In parseoptions opts = ibmgraphics,autoquiver,noautoopen
In parseoptions opts = autoquiver,noautoopen
In parseoptions opts = noautoopen
In parseoptions opts = number_pad:0,msg_window:reversed
In parseoptions opts = msg_window:reversed
In parseoptions opts = hilite_pet,hilite_pile,pickup_burden:unencumbered
In parseoptions opts = hilite_pile,pickup_burden:unencumbered
In parseoptions opts = pickup_burden:unencumbered
In parseoptions opts = disclose:yi ya yv yg yc yo
In parseoptions opts = boulder:`
In parseoptions opts = sortloot:none

Looks like it just processes the first option passed to it.

    if ((op = index(opts, ',')) != 0) {
        *op++ = 0;
        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

I guess this sticks a 0 where the first comma is so the rest of the function
can use opts as if it didn't have a comma.

Then it calls itself with op pointing to the string after the comma.

[bobby@localhost src]$ grep parseoptions *.c
files.c:        ++bufp; /* skip '='; parseoptions() handles spaces */
files.c:        if (!parseoptions(bufp, TRUE, TRUE))
options.c:             * parseoptions() will check each individually
options.c:            (void) parseoptions(opts, TRUE, FALSE);
options.c:/* paranoia[] - used by parseoptions() and special_handling() */
options.c:parseoptions(opts, tinitial, tfrom_file)
options.c:        if (!parseoptions(op, initial, from_file))
options.c:         * or prompt for new values. In most cases, call parseoptions()
options.c:                (void) parseoptions(buf, setinitial, fromfile);
options.c:                    (void) parseoptions(buf, setinitial, fromfile);
options.c:        /* parseoptions will prompt for the list of types */
options.c:        (void) parseoptions(strcpy(buf, "pickup_types"),
vision.c: *      + After an option has changed that affects vision [parseoptions()]

Mostly return value is ignored except in files.c.

        if (!parseoptions(bufp, TRUE, TRUE))
            retval = FALSE;

this uses returned value in files.c
in function 

boolean
parse_config_line(origbuf)
char *origbuf;

But what the heck is parse_config_line doing?

boolean
parse_config_line(origbuf)
char *origbuf;
{
    write_debug_file_str("In parse_config_line origbuf = %s\n",origbuf);


clear; cat /dev/null > debugfile.log;tail -f debugfile.log

In parse_config_line origbuf = WIZARDS=bobby
In parse_config_line origbuf = EXPLORERS=*
In parse_config_line origbuf = MAXPLAYERS=10
In parse_config_line origbuf = GDBPATH=/usr/bin/gdb
In parse_config_line origbuf = GREPPATH=/bin/grep
In parse_config_line origbuf = PANICTRACE_GDB=1
In parse_config_line origbuf = PANICTRACE_LIBC=2
More than MAX_LINE_SIZE character string in write_debug_file_str
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=number_pad:0,msg_window:reversed
More than MAX_LINE_SIZE character string in write_debug_file_str
In parse_config_line origbuf = OPTIONS=disclose:yi ya yv yg yc yo
In parse_config_line origbuf = OPTIONS=boulder:`
In parse_config_line origbuf = OPTIONS=sortloot:none

I guess these are the uncommented lines in sysconf as well as the .nethackrc

[bobby@localhost nethack]$ grep = /home/bobby/nethack/games/lib/bobbyhackdir/sysconf | grep -v \#
WIZARDS=bobby
EXPLORERS=*
MAXPLAYERS=10
GDBPATH=/usr/bin/gdb
GREPPATH=/bin/grep
PANICTRACE_GDB=1
PANICTRACE_LIBC=2

I'm thinking autoletter should be an option since it is related to game
play and not configuration of the system relative to Linux.

5/10/2020

[bobby@localhost ~]$ diff .nethackrc .nethackrc.workingsave

.nethackrc.workingsave is my normal options for nethack 3.6.x

[bobby@localhost ~]$ cat .nethackrc
OPTIONS=autoletter:blindfold:1

simple test of one autoletter option.

[bobby@localhost ~]$ bobbyhack -D

OPTIONS=autoletter:blindfold:1
 * Line 1: Unknown option 'autoletter:blindfold:1'.

1 error in /home/bobby/.nethackrc.


Hit return to continue:

probably here

[bobby@localhost src]$ grep "Unknown option" *.c
options.c:    config_error_add("Unknown option '%s'", opts);

    /* out of valid options */
    config_error_add("Unknown option '%s'", opts);
    return FALSE;
}

this is called if you fall through to this point.

This is the end of parseoptions in options.c

Maybe add the autoletter support here.

/* compound options, for option_help() and external programs like Amiga
 * frontend */
static struct Comp_Opt {
    const char *name, *descr;
    int size; /* for frontends and such allocating space --
               * usually allowed size of data in game, but
               * occasionally maximum reasonable size for
               * typing when game maintains information in
               * a different format */
    int optflags;
} compopt[] = {
    { "align", "your starting alignment (lawful, neutral, or chaotic)", 8,
      DISP_IN_GAME },
    { "align_message", "message window alignment", 20, DISP_IN_GAME }, /*WC*/
    { "align_status", "status window alignment", 20, DISP_IN_GAME },   /*WC*/

Seems like we may not need to add autoletter to compopt[] in options.c at first just to get it working
but later to add it to the help for options.

Probably just need to handle autoletter at the end of parseoptions for now.

    /* control over whether highlights should be displayed, and for how long */
    fullname = "statushilites";
    if (match_optname(opts, fullname, 9, TRUE)) {
#ifdef STATUS_HILITES
        if (negated) {
            iflags.hilite_delta = 0L;
        } else {
            op = string_for_opt(opts, TRUE);
            iflags.hilite_delta = (op == empty_optstr || !*op) ? 3L : atol(op);
            if (iflags.hilite_delta < 0L)
                iflags.hilite_delta = 1L;
        }
        if (!tfrom_file)
            reset_status_hilites();
        return retval;
#else
        config_error_add("'%s' is not supported", fullname);
        return FALSE;
#endif
    }

possible example. could use fullname = "autoletter";

Not sure if I should use something like

#ifdef AUTOLETTER to bracket the code? Kind of gross.

If I am going to do it I should do something like

#ifdef DEBUG_FILE for the debugging code.

I think retval is set by the earlier recursive call

        if (!parseoptions(op, initial, from_file))
            retval = FALSE;

So if current option is good return retval otherwise
return FALSE.

5/19/2020

in options.c

/* check whether a user-supplied option string is a proper leading
   substring of a particular option name; option string might have
   a colon or equals sign and arbitrary value appended to it */
boolean
match_optname(user_string, opt_name, min_length, val_allowed)
const char *user_string, *opt_name;
int min_length;
boolean val_allowed;

I guess use this:

    /* automatically set objects to a specific letter */
    fullname = "autoletter";
    if (match_optname(opts, fullname, 10, TRUE)) {
        write_debug_file_str("autoletter opts = %s\n",opts);
        return retval;
    }
    
[bobby@localhost ~]$ cat .nethackrc
OPTIONS=autoletter:blindfold:1

debug output:

autoletter opts = autoletter:blindfold:1

switched to 7 letters so autolet works.

autoletter opts = autoletter:blindfold:1
autoletter opts = autolet:blindfold:1
autoletter opts = autoletter:blindfold:1

Duh.

should be like this

autoletter opts = autoletter:b:blindfold:1

letter:object type or name:integer priority


void
add_autoletter(char *opts)
{
    write_debug_file_str("In add_autoletter opts = %s\n",opts);
}

shell of where to do actual insert into data structure

strchr to find a string

need to add validation code in add_autoletter
to make sure isn't a huge string et. al. and that
it has the proper number of :'s and all.
Also having it default to priority 1 without the last
: and having a prefix for autoletter.

might need config_error_add and similar routines
to report an error

/* varargs 'config_error_add()' moved to pline.c */

config_error_add("Unknown %s '%s'", fullname, op);

5/20/2020

add_autoletter is parsing out the autoletter option
pretty well with error checking.

getting super annoying clock skew message need to figure
out how to sync Linux VM clock with my Windows laptop host.
Maybe part of tools for virtualbox?

should I put this code in its own function and call
it from add_autoletter?

maybe parse_autoletter?

5/23/2020

was getting weird time skew errors until I realized that my
Windows 10 laptop was the one that was out of sync somehow.

Had to go to Date and time settings and click on
Sync now button to resolve.

Moved autoletter option parsing code into
parse_autoletter to keep add_autoletter
cleaner.

5/25/2020

Need to save in an array now.

boolean
insert_autoletter(char letter,char *object_type_or_name, int priority)

I guess since the array is static and the debug file commands are in files.c
I cannot write a debug print command to directly access the array.

I could write interface functions to get num_autoletter and
a specific element of the array.

int num_autoletter()

boolean get_autoletter(int index,char *letter,char *object_type_or_name, int *priority)

then I could write 

void
write_debug_file_autoletter()

to dump the entire array in a nicely formatted output.

Could test with my entire option list as I want to use it

(blindfold, lamp, etc.)

Need to test all the bad cases such as

not a alpha letter

priority < 1

also need to add a check for duplicate object type or name.
and make sure there is a meaningful error message.

should I add config error messages to insert_autoletter
itself.

maybe create

int lookup_autoletter(char *object_type_or_name)

returns index into array >= 0 < MAX_AUTO_OPTIONS

then combine with get_autoletter to return actual values.

that way get_autoletter can be used to interate through
entire array and to pull data back for a looked up
index

